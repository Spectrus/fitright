<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Available Leather Jackets - Fitrite</title>
  <!-- Import Special Elite from Google Fonts for the header and leather jackets section -->
  <link href="https://fonts.googleapis.com/css2?family=Special+Elite&display=swap" rel="stylesheet">
  
  <link rel="preconnect" href="https://api.fashn.ai" crossorigin>
  <link rel="dns-prefetch" href="https://api.fashn.ai">
  <style>
    /* CSS Reset and Box Model Standardization */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    /* Minus button style aligned with scarves page */
    .basket-row { position: relative; }
    /* Desktop: minus hidden by default, shown on row hover */
    #basketDropdown .basket-row { position: relative; }
    #basketDropdown .basket-minus-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: #000;
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      border: none;
      font-size: 1em;
      cursor: pointer;
      opacity: 0;
      pointer-events: none;
      transition: opacity 140ms ease-in-out;
    }
    #basketDropdown .basket-row:hover .basket-minus-btn,
    #basketDropdown .basket-minus-btn:hover,
    #basketDropdown .basket-minus-btn:focus,
    #basketDropdown .basket-minus-btn:active {
      opacity: 1;
      pointer-events: auto;
    }
    /* Mobile: minus always visible */
    #basketDropdownMobile .basket-minus-btn {
      opacity: 1 !important;
      pointer-events: auto !important;
      position: absolute;
      top: 50%;
      right: 8px;
      transform: translateY(-50%);
      width: 22px;   /* match desktop */
      height: 22px;  /* match desktop */
      border-radius: 50%;
      background: #000;
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      border: none;
      font-size: 1em; /* match desktop */
      cursor: pointer;
    }
    /* Global Styles */
    body {
      margin: 0;
      padding: 0;
      background: #f4f4f4;
      font-family: Arial, sans-serif;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    
    /* Header Styles */
    header {
      position: relative;
      z-index: 1000;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px;
      background-color: transparent;
      width: 100%;
      font-family: 'Special Elite', monospace;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    
    header .logo h1 {
      margin: 0;
      font-size: 1.5em;
      font-weight: normal;
      color: black;
    }
    
    header .logo p {
      margin: 3px 0 0;
      font-size: 0.8em;
      font-style: italic;
      color: black;
    }
    
    /* Mobile Menu Toggle */
    .file-input {
      display: none !important;
      visibility: hidden !important;
      opacity: 0 !important;
      position: absolute !important;
      left: -9999px !important;
      width: 0 !important;
      height: 0 !important;
    }
    
    .menu-toggle {
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      width: 30px;
      height: 22px;
      cursor: pointer;
      z-index: 20;
      position: relative;
    }
    
    .menu-toggle span {
      display: block;
      position: absolute;
      left: 0;
      height: 3px;
      width: 100%;
      background-color: #333;
      border-radius: 3px;
      transition: transform 0.25s ease, opacity 0.25s ease;
    }
    .menu-toggle span:nth-child(1) { top: 0; }
    .menu-toggle span:nth-child(2) { top: 9px; }
    .menu-toggle span:nth-child(3) { top: 18px; }
    /* X transformation when menu is open */
    .menu-toggle.active span:nth-child(1),
    #mobileNav.active + #menuToggle span:nth-child(1) { transform: translateY(9px) rotate(45deg); }
    .menu-toggle.active span:nth-child(2),
    #mobileNav.active + #menuToggle span:nth-child(2) { opacity: 0; }
    .menu-toggle.active span:nth-child(3),
    #mobileNav.active + #menuToggle span:nth-child(3) { transform: translateY(-9px) rotate(-45deg); }
    
    header nav {
      padding-right: 0;
    }
    
    header nav ul {
      list-style: none;
      display: flex;
      gap: 15px;
      margin: 0;
      padding: 0;
    }
    
    header nav ul li a {
      color: black;
      text-decoration: none;
      transition: color 0.3s;
      pointer-events: auto;
      padding: 5px 10px;
      display: block;
    }
    
    header nav ul li a:hover {
      text-decoration: underline;
      color: black;
    }
    
    /* BASKET STYLES */
    /* Mobile Navigation */
    @media (max-width: 767px) {
      .menu-toggle { display: flex; }
      
      header nav {
        position: fixed;
        top: 0;
        right: -100%;
        width: 80%;
        max-width: 300px;
        height: 100vh;
        background-color: white;
        z-index: 100;
        transition: right 0.3s ease;
        box-shadow: -5px 0 15px rgba(0,0,0,0.1);
        padding: 80px 20px 20px;
      }
      
      header nav.active { right: 0; }
      
      header nav ul {
        flex-direction: column;
      }
      
      header nav ul li {
        margin-right: 0;
        margin-bottom: 15px;
      }
      
      .basket-desktop { display: none !important; }
      .basket-mobile { display: block !important; }
      #basketDropdown {
        position: static !important;
        right: auto !important;
        left: auto !important;
        min-width: unset !important;
        max-width: 100% !important;
        width: 100% !important;
        margin: 0 0 0 0 !important;
        box-shadow: none !important;
        border-radius: 0 0 15px 15px !important;
        z-index: 1 !important;
        padding: 0 0 10px 0 !important;
        max-height: 250px !important;
        overflow-y: auto !important;
      }
      #basketDropdown.show {
        box-shadow: none !important;
      }
    }
    
    /* Desktop Navigation */
    @media (min-width: 768px) {
      .menu-toggle {
        display: none;
      }
      
      header nav {
        position: static;
        width: auto;
        height: auto;
        background-color: transparent;
        padding: 0;
        box-shadow: none;
      }
      
      header nav ul {
        flex-direction: row;
        gap: 15px;
      }
      
      header nav ul li {
        margin-right: 0;
        margin-bottom: 0;
      }
      
      .basket-desktop { display: block !important; }
      .basket-mobile { display: none !important; }
    }
    
    /* Basket Dropdown Animation */
    #basketDropdown {
      opacity: 0;
      transform: translateY(-10px);
      pointer-events: none;
      transition: opacity 0.3s, transform 0.3s;
      display: none; /* Start hidden, show with JavaScript */
      max-height: 400px;
      overflow-y: auto;
    }
    #basketDropdown.show {
      opacity: 1;
      transform: translateY(0);
      pointer-events: auto;
    }
    
    /* Mobile Basket Dropdown Animation */
    #basketDropdownMobile {
      opacity: 0;
      transform: translateY(-10px);
      pointer-events: none;
      transition: opacity 0.3s, transform 0.3s;
      display: block;
      max-height: 250px;
      overflow-y: auto;
      background: #fff;
      border: 1px solid #ddd;                /* Outline like index.html */
      border-radius: 0 0 15px 15px;          /* Rounded bottom corners */
      box-shadow: 0 4px 16px rgba(0,0,0,0.15); /* Subtle shadow */
    }
    #basketDropdownMobile.show {
      opacity: 1;
      transform: translateY(0);
      pointer-events: auto;
    }
    
    /* Fade animation for basket product row */
    .basket-fade-out {
      opacity: 0;
      transition: opacity 0.3s;
    }
    .basket-fade-in {
      opacity: 1;
      transition: opacity 0.3s;
    }
    
    
    /* Hide/show basket button for desktop/mobile */
    .basket-desktop { display: block; }
    .basket-mobile { display: none; }
    @media (max-width: 767px) {
      .basket-desktop { display: none !important; }
      .basket-mobile { display: block !important; }
      #basketDropdown {
        right: 10px !important;
        left: 10px !important;
        min-width: unset !important;
        max-width: 95vw !important;
      }
    }
    
    /* Highlight basket button in mobile menu on hover like other links */
    .basket-mobile-btn:hover span:first-child {
      text-decoration: underline;
      color: black;
    }
    
    /* Only add border-bottom to basket rows except the last */
    .basket-row:not(:last-child) {
      border-bottom: 1px solid #eee;
    }
    
    /* Clear Basket Button Slide-up Animation */
    #basketDropdownFooter {
      transition: all 0.3s ease;
      transform: translateY(100%);
      opacity: 0;
      overflow: hidden;
      position: relative;
    }
    
    #basketDropdown:hover #basketDropdownFooter {
      transform: translateY(0);
      opacity: 1;
    }
    
    #clearBasketBtn {
      transition: all 0.2s ease;
    }
    
    #clearBasketBtn:hover {
      background: #a00 !important;
      transform: scale(1.05);
    }
    /* Enhanced fade animation for basket product row */
    .basket-fade-out {
      opacity: 0;
      transform: translateX(-20px) scale(0.95);
      background-color: rgba(255, 0, 0, 0.05);
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      pointer-events: none;
    }
    .basket-fade-in {
      opacity: 1;
      transform: translateX(0) scale(1);
      background-color: transparent;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    
    /* Hide/show basket button for desktop/mobile */
    .basket-desktop { display: block; }
    .basket-mobile { display: none; }
    
    /* Clear Basket Button Slide-up Animation */
    #basketDropdownFooter {
      transition: all 0.3s ease;
      transform: translateY(100%);
      opacity: 0;
      overflow: hidden;
      position: relative;
    }
    
    #basketDropdown:hover #basketDropdownFooter {
      transform: translateY(0);
      opacity: 1;
    }
    
    #clearBasketBtn {
      transition: all 0.2s ease;
    }
    
    #clearBasketBtn:hover {
      background: #a00 !important;
      transform: scale(1.05);
    }
    
    #basketDropdownFooterMobile {
      transition: all 0.3s ease;
      transform: translateY(100%);
      opacity: 0;
      overflow: hidden;
      position: relative;
    }
    
    #basketDropdownMobile:hover #basketDropdownFooterMobile {
      transform: translateY(0);
      opacity: 1;
    }
    
    #clearBasketBtnMobile {
      transition: all 0.2s ease;
    }
    
    #clearBasketBtnMobile:hover {
      background: #a00 !important;
      transform: scale(1.05);
    }
    @media (max-width: 767px) {
      .basket-desktop { display: none !important; }
      .basket-mobile { display: block !important; }
      #basketDropdown {
        right: 10px !important;
        left: 10px !important;
        min-width: unset !important;
        max-width: 95vw !important;
      }
    }
    
    /* Highlight basket button in mobile menu on hover like other links */
    .basket-mobile-btn:hover span:first-child {
      text-decoration: underline;
      color: black;
    }
    
    /* Only add border-bottom to basket rows except the last */
    .basket-row:not(:last-child) {
      border-bottom: 1px solid #eee;
    }
    
    /* Mobile basket row styles */
    .basket-mobile-row {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
      padding: 0 0 0 0;
      background: none;
      border-radius: 0;
      box-shadow: none;
      position: relative;
      min-height: 48px;
    }
    .basket-mobile-row:last-child {
      margin-bottom: 0;
    }
    .basket-mobile-row img {
      width: 38px;
      height: 38px;
      object-fit: contain;
      border-radius: 8px;
      margin-right: 8px;
      background: #fafafa;
    }
    .basket-mobile-row .basket-mobile-info {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      min-width: 0;
    }
    .basket-mobile-row .basket-mobile-title {
      font-family: 'Special Elite', monospace;
      font-size: 1em;
      text-transform: uppercase;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .basket-mobile-row .basket-mobile-price {
      font-size: 1em;
      font-weight: bold;
      font-family: 'Special Elite', monospace;
      margin-right: 8px;
      display: inline-block;
    }
    .basket-mobile-row .basket-mobile-qty {
      font-size: 0.95em;
      color: #555;
      font-family: 'Special Elite', monospace;
      text-transform: uppercase;
      display: inline-block;
    }
    .basket-mobile-row .basket-mobile-size {
      font-size: 0.95em;
      color: #555;
      font-family: 'Special Elite', monospace;
      text-transform: uppercase;
      display: none;
    }
    
    
    /* Search Bar */
    #search-bar {
      background-color: transparent;
      padding: 15px;
      text-align: center;
      border-bottom: 1px solid #ddd;
      width: 100%;
    }
    
    #searchInput {
      width: 90%;
      max-width: 600px;
      padding: 10px 15px;
      font-size: 1em;
      border: 1px solid #ccc;
      border-radius: 25px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      outline: none;
    }
    
    #searchInput:focus {
      border-color: #333;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }
    
    /* Main Title - Matching Scarves Page */
    .main-title {
      text-align: center;
      font-family: 'Special Elite', monospace;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin: 20px 0;
      font-size: 1.8em;
      font-weight: normal;
    }
    
    /* Products Grid - Responsive grid like bags page */
    .products {
      display: grid;
      grid-template-columns: repeat(4, 1fr); /* Default to 4 columns for desktop */
      gap: 20px;
      padding: 20px;
      background-color: #f4f4f4;
      width: 100%;
      max-width: 1400px;
      margin: 0 auto;
    }
    
    .product {
      background-color: white;
      border: 1px solid #ddd;
      border-radius: 15px;
      box-shadow: 0px 4px 10px rgba(0,0,0,0.2);
      overflow: hidden;
      text-align: center;
      padding: 0; /* Match leather_jackets1 full-width tag behavior */
      cursor: pointer;
      transition: transform 0.3s, box-shadow 0.3s;
      position: relative;
      touch-action: manipulation;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 200px; /* Ensure consistent height */
    }
    
    .product:hover {
      transform: scale(1.02);
      box-shadow: 0px 6px 15px rgba(0,0,0,0.3);
    }
    
    /* Image Container - fixed height (original size) */
    .image-container {
      display: flex; /* Match footwear centering */
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 200px; /* Keep the original visual size */
      margin-bottom: 10px;
      overflow: hidden; /* Clip inner corners */
      border-radius: 0; /* Let discount tag span full width at top */
      background: #fff; /* White background like footwear */
    }
    
    .image-container img {
      display: block; /* Avoid inline baseline shifts */
      max-width: 95%;
      max-height: 95%;
      width: auto;
      height: auto;
      object-fit: contain;
      object-position: center center;
      border-radius: 15px; /* Match footwear/sunglasses */
    }
    
    /* Product Text Styling - Matching Scarves Page */
    .product-name {
      font-family: 'Special Elite', monospace;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-size: 1.1em;
      margin-bottom: 5px;
    }
    
    .product-price {
      font-family: 'Special Elite', monospace;
      font-size: 1em;
    }
    
    /* Discount Tag Styles - match leather_jackets1 full-width ribbon */
    .discount-tag {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      padding: 8px 0;
      border-radius: 15px 15px 0 0; /* Rounded top corners to match card */
      font-size: 1.05rem;
      font-weight: bold;
      z-index: 10;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      text-align: center;
      font-family: 'Special Elite', monospace;
      letter-spacing: 0.5px;
    }
    
    /* Red Tag (≤ 55%) */
    .discount-tag.red {
      background-color: #ff0000;
      color: white;
    }
    
    /* Gold Tag (> 55%) */
    .discount-tag.gold {
      background-color: #ffd700;
      color: #333;
    }
    
    /* Price Styling for Discounted Products */
    .original-price {
      text-decoration: line-through;
      color: #888;
      margin-right: 5px;
    }
    
    .new-price {
      color: green;
      font-weight: bold;
    }
    
    /* Footer */
    footer {
      text-align: center;
      background-color: transparent;
      color: #333;
      font-size: 0.9em;
      margin: 20px 0;
      padding: 15px;
      width: 100%;
    }
    
    footer p {
      margin: 5px 0;
    }
    
    /* Modal Styles - Responsive */
    /* Embed mode adjustments: collapse outer chrome when inside iframe */
    html.embed, body.embed {
      overflow: hidden;
      background: #0b0b0b;
    }
    body.embed header,
    body.embed #search-bar,
    body.embed .main-title,
    body.embed footer,
    body.embed nav {
      display: none !important;
    }
    body.embed .products {
      display: none !important;
    }
    body.embed #productModal,
    body.embed #modelUploadSection,
    body.embed #finalResultScreen {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      margin: 0;
      border-radius: 0;
    }
    body.embed #productModal { display: none !important; }
    body.embed .modal { background: transparent !important; }
    body.embed .modal-content {
      max-width: min(1200px, 98vw);
      width: 98vw;
      height: auto;
      margin: 0 auto;
    }
    .modal {
      display: none;
      position: fixed;
      z-index: 999;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.4s ease;
      justify-content: center;
      align-items: center;
    }
    
    .modal.show {
      display: flex;
      opacity: 1;
      pointer-events: auto;
    }
    
    @keyframes fadeInSlide {
      0% {
        opacity: 0;
        transform: translateY(-50px);
      }
      100% {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .close-btn {
      position: absolute;
      top: 0.5rem;
      right: 0.75rem;
      font-size: 1.2rem;
      font-weight: bold;
      cursor: pointer;
      touch-action: manipulation;
    }
    
    .close-btn:hover {
      color: red;
    }
    
    .modal .image-container {
      display: block;
      margin: 0 auto 10px;
      border-radius: 0;
      overflow: hidden;
    }
    
    .modal .image-container img {
      width: 100%;
      height: auto;
      object-fit: cover;
      display: block;
    }
    
    /* Added image element for modal content */
    #modalProductImage {
      width: 100%;
      max-width: 250px;
      height: auto;
      object-fit: contain;
      border-radius: 15px;
      margin-bottom: 1rem;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    }
    
    .proceed-btn {
      background-color: #000;
      color: #fff;
      border: none;
      padding: 1rem 1.5rem;
      margin-top: 1rem;
      cursor: pointer;
      font-size: 1rem;
      border-radius: 30px;
      transition: background-color 0.3s;
      touch-action: manipulation;
      width: 100%;
      text-align: center;
    }
    
    .proceed-btn:hover {
      background-color: #333;
    }
    
    #sizeSelector {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
      background-repeat: no-repeat;
      background-position: right 1rem center;
      background-size: 1em;
      padding-right: 2.5rem;
    }
    
    /* Toast Notification */
    #toast {
      position: fixed;
      top: 20px;
      right: 20px;
      background-color: #333;
      color: #fff;
      padding: 10px 15px;
      border-radius: 15px;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
      z-index: 10000;
    }
    
    #toast.show {
      opacity: 1;
    }

    /* AI Preview Disclaimer Banner */
    .ai-preview-disclaimer {
      position: fixed;
      left: 50%;
      bottom: 20px;
      transform: translateX(-50%) translateY(10px);
      background: #28a745; /* green banner with white text */
      color: #fff;
      padding: 10px 16px;
      border-radius: 12px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.25);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.4s ease, transform 0.4s ease;
      z-index: 5000;
      font-size: 0.95em;
      text-align: center;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      text-transform: none;
      letter-spacing: 0.02em;
    }
    .ai-preview-disclaimer.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }

    /* Watermark over AI result */
    .fitrite-watermark {
      position: absolute;
      right: 6px;
      bottom: 6px;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      font-family: Georgia, "Times New Roman", Times, serif;
      color: #fff;
      letter-spacing: 0.05em;
      text-shadow: none;
      z-index: 1005;
      pointer-events: none;
      text-transform: uppercase;
      font-size: clamp(11px, 1.3vw, 18px);
      font-weight: 300;
      text-align: center;
    }
    .fitrite-watermark .fit-line {
      display: block;
      width: 80px;
      height: 2px;
      background: #fff;
      margin: 0 0 3px 0;
      border-radius: 1px;
      align-self: center;
    }

    /* Try Button Styles - Same as other buttons but with Glacier effect */
    .try-on-btn {
      background: linear-gradient(135deg, #a3d5ff 0%, rgba(255, 255, 255, 0.9) 100%);
      color: #fff;
      border: none;
      padding: 1rem 1.5rem;
      margin-top: 1rem;
      cursor: pointer;
      font-size: 1rem;
      border-radius: 30px;
      transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      touch-action: manipulation;
      width: 100%;
      text-align: center;
      position: relative;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(163, 213, 255, 0.4);
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .try-on-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, 
          transparent, 
          rgba(255, 180, 180, 0.35), 
          rgba(255, 200, 160, 0.35), 
          rgba(255, 255, 200, 0.35), 
          rgba(200, 255, 200, 0.4), 
          rgba(200, 230, 255, 0.4), 
          rgba(230, 200, 255, 0.35), 
          rgba(255, 200, 230, 0.35), 
          rgba(255, 255, 255, 0.5),
          transparent);
      opacity: 1;
      z-index: 1;
      animation: glacier-rainbow-sweep 4s infinite;
    }

    @keyframes glacier-rainbow-sweep {
      0% { left: -100%; opacity: 0.4; }
      50% { left: 100%; opacity: 0.7; }
      100% { left: -100%; opacity: 0.4; }
    }

    .try-on-btn:hover:not(:disabled) {
      transform: translateY(-5px) scale(1.03);
      box-shadow: 0 20px 40px rgba(163, 213, 255, 0.6);
      background: linear-gradient(135deg, #87ceeb 0%, rgba(255, 255, 255, 0.95) 100%);
    }

    .try-on-btn:active:not(:disabled) {
      transform: translateY(-2px) scale(0.98);
      box-shadow: 0 10px 25px rgba(163, 213, 255, 0.4);
    }

    /* Fade out animation for modal elements */
    .fade-out-element {
      opacity: 1;
      transition: opacity 0.6s ease-out, transform 0.6s ease-out;
    }

    .fade-out-element.hidden {
      opacity: 0;
      transform: translateY(-20px);
      pointer-events: none;
    }

    /* Model Upload Section Styles */
    .model-upload-section {
      display: none;
      text-align: center;
    }

    .model-upload-section.show {
      display: block;
    }

    .upload-container {
      background: white;
      border-radius: 15px;
      padding: 20px;
      margin: 20px auto;
      max-width: 500px;
      box-shadow: 0px 4px 10px rgba(0,0,0,0.2);
      transition: all 0.6s ease;
    }

    .upload-container.has-photo {
      background: transparent;
      box-shadow: none;
      padding: 0;
      border-radius: 0;
    }

    /* Mobile specific positioning - Corrigido para melhor responsividade */
    @media (max-width: 768px) {
      .model-upload-section {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) translateY(100vh);
        width: 90vw;
        max-width: 400px;
        margin: 0;
        z-index: 1001;
        transition: transform 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        box-sizing: border-box;
        max-height: 90vh;
        overflow-y: auto;
      }

      .model-upload-section.show {
        transform: translate(-50%, -50%) translateY(0);
      }

      .model-upload-section.scroll-up {
        animation: scrollUpMobile 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
      }

      .upload-container {
        margin: 0 0 20px 0;
        width: 100%;
        box-sizing: border-box;
      }
    }

    @keyframes scrollUpMobile {
      from {
        transform: translate(-50%, -50%) translateY(100vh);
        opacity: 0;
      }
      to {
        transform: translate(-50%, -50%) translateY(0);
        opacity: 1;
      }
    }

    /* Desktop positioning - Corrigido para melhor responsividade */
    @media (min-width: 769px) {
      .model-upload-section {
        position: fixed;
        left: 65%;
        top: 50%;
        transform: translate(0, -50%);
        width: 300px;
        max-width: 35vw;
        display: none;
        animation: fadeInRight 0.6s ease-out;
        z-index: 1004;
        box-sizing: border-box;
        max-height: 90vh;
        overflow-y: auto;
      }

      .model-upload-section.show {
        display: block;
      }

      .upload-container {
        margin: 0 0 20px 0;
        width: 100%;
        box-sizing: border-box;
      }

      @keyframes fadeInRight {
        from {
          opacity: 0;
          transform: translate(30px, -50%);
        }
        to {
          opacity: 1;
          transform: translate(0, -50%);
        }
      }
    }

    @keyframes slideInUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Desktop Try-On Animation - Container Fade Out */
    @media (min-width: 769px) {
      .modal-content.try-on-container-fadeout {
        animation: containerFadeOut 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
      }
    }

    /* Removed modal-content-hidden behavior to match v1 flow */

    @keyframes containerFadeOut {
      from {
        opacity: 1;
        transform: translateX(0);
      }
      to {
        opacity: 0;
        transform: translateX(-50px);
      }
    }

    /* Keep product image visible */
    .modal-content.try-on-container-fadeout #modalProductImage {
      position: absolute;
      z-index: 1002;
      opacity: 1 !important;
      transform: none !important;
      animation: productImageFloat 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
    }

    @keyframes productImageFloat {
      from {
        position: relative;
        z-index: 1;
      }
      to {
        position: absolute;
        z-index: 1002;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
      }
    }

    .upload-title {
      font-family: 'Special Elite', monospace;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-size: 1.3em;
      margin-bottom: 20px;
      color: #333;
    }

    .upload-container {
      background: white;
      border-radius: 15px;
      padding: 20px;
      margin: 20px auto;
      max-width: 500px;
      box-shadow: 0px 4px 10px rgba(0,0,0,0.2);
      transition: all 0.6s ease;
      position: relative;
    }

    .upload-container.has-photo {
      background: transparent;
      box-shadow: none;
      padding: 0;
      border-radius: 15px;
      overflow: hidden;
      width: 300px;
      height: 400px;
    }

    /* Mobile adjustments for upload container */
    @media (max-width: 768px) {
      .upload-container.has-photo {
        width: 350px;
        height: 450px;
      }
    }

    .person-upload-area {
      position: relative;
      background: #f8f9fa;
      border: 3px dashed #dee2e6;
      border-radius: 12px;
      padding: 20px;
      cursor: pointer;
      transition: all 0.6s ease;
      width: 250px;
      height: 250px;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      margin: 0 auto;
    }

    .person-upload-area.has-photo {
      border: none;
      background: transparent;
      padding: 0;
      width: 100%;
      height: 100%;
      border-radius: 0;
      min-height: auto;
      box-shadow: none;
      position: absolute;
      top: 0;
      left: 0;
      margin: 0;
    }

    .person-upload-area.has-photo img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 15px;
    }

    .person-upload-area.has-photo:hover {
      border: none;
      background: transparent;
    }

    .person-photo-preview {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 15px;
      display: none;
      opacity: 0;
      transition: opacity 0.8s ease-in-out;
    }

    .person-upload-inner.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .upload-prompt {
      text-align: center;
    }

    .upload-prompt.hidden {
      display: none;
    }

    .upload-icon {
      font-size: 3em;
      margin-bottom: 15px;
      color: #666;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .upload-icon svg {
      width: 80px;
      height: 80px;
      stroke: #666;
      transition: stroke 0.3s ease;
    }

    .person-upload-area:hover .upload-icon svg {
      stroke: #007bff;
    }

    .upload-text {
      font-size: 1.1em;
      color: #333;
      margin-bottom: 8px;
      font-weight: 500;
    }

    .upload-subtext {
      font-size: 0.9em;
      color: #666;
    }

    .person-photo-preview {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      border-radius: 12px;
      display: none;
      opacity: 0;
      transition: opacity 0.8s ease-in-out;
    }

    .person-photo-preview.show {
      display: block;
      opacity: 1;
    }

    .person-photo-preview.fade-out {
      opacity: 0;
    }

    .result-in-place {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      transition: opacity 1.2s ease-in-out;
    }

    .result-in-place.show {
      opacity: 1;
    }

    .result-image-in-place {
      width: 100%;
      height: 100%;
      object-fit: contain;
      border-radius: 12px;
    }

    .result-back-btn {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      border: none;
      border-radius: 50%;
      width: 35px;
      height: 35px;
      font-size: 1.2em;
      cursor: pointer;
      opacity: 0;
      transition: all 0.3s ease;
    }

    .result-back-btn.show {
      opacity: 1;
    }

    .result-back-btn:hover {
      background: rgba(0,0,0,0.9);
      transform: scale(1.1);
    }

    .processing-overlay-local {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.3);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 8px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
      z-index: 1006; /* ensure overlay is above any inner content */
      overflow: hidden; /* prevent scrollbars when anchored to smaller areas */
    }

    .processing-overlay-local.show {
      opacity: 1;
      pointer-events: auto;
      position: fixed;
      left: 0;
      top: 0;
      width: 100vw;
      height: 100vh;
      z-index: 3000;
    }

    /* Adiciona blur diretamente na imagem durante processamento */
    .person-photo-preview.processing {
      filter: blur(8px);
      transition: filter 0.3s ease;
    }

    .person-photo-preview.processing-complete {
      filter: blur(0px);
      transition: filter 0.5s ease;
    }

    .processing-content-local {
      text-align: center;
      padding: 20px;
    }

    .processing-spinner {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      margin: 0 auto 15px;
      position: relative;
      background: conic-gradient(
        from 0deg,
        rgba(255, 180, 180, 0.8),
        rgba(255, 200, 160, 0.8),
        rgba(255, 255, 200, 0.9),
        rgba(200, 255, 200, 0.8),
        rgba(200, 230, 255, 0.9),
        rgba(230, 200, 255, 0.8),
        rgba(255, 200, 230, 0.8),
        rgba(255, 255, 255, 0.9),
        rgba(255, 180, 180, 0.8)
      );
      animation: spin 1s linear infinite !important;
      animation-play-state: running !important;
    }

    .processing-spinner::before {
      content: '';
      position: absolute;
      top: 4px;
      left: 4px;
      right: 4px;
      bottom: 4px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 50%;
      backdrop-filter: blur(8px);
    }

    @keyframes progress-spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .processing-text {
      font-size: 1.1em;
      font-weight: 600;
      color: #fff;
      margin-bottom: 5px;
      text-shadow: 0 1px 3px rgba(0,0,0,0.3);
    }

    .processing-subtext {
      font-size: 0.9em;
      color: rgba(255, 255, 255, 0.9);
      margin-bottom: 15px;
      text-shadow: 0 1px 2px rgba(0,0,0,0.2);
    }

    .progress-bar {
      width: 100%;
      height: 6px;
      background: rgba(163, 213, 255, 0.2);
      border-radius: 3px;
      overflow: hidden;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(135deg, #a3d5ff 0%, rgba(255, 255, 255, 0.9) 100%);
      width: 0%;
      transition: width 0.3s ease;
      position: relative;
      overflow: hidden;
      border-radius: 3px;
      box-shadow: 0 2px 6px rgba(163, 213, 255, 0.4);
    }

    .progress-fill::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, 
          transparent, 
          rgba(255, 180, 180, 0.35), 
          rgba(255, 200, 160, 0.35), 
          rgba(255, 255, 200, 0.35), 
          rgba(200, 255, 200, 0.4), 
          rgba(200, 230, 255, 0.4), 
          rgba(230, 200, 255, 0.35), 
          rgba(255, 200, 230, 0.35), 
          rgba(255, 255, 255, 0.5),
          transparent);
      opacity: 1;
      z-index: 1;
      animation: glacier-rainbow-sweep 3s infinite !important;
      animation-play-state: running !important;
    }

    .remove-photo-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      border: none;
      border-radius: 50%;
      width: 35px;
      height: 35px;
      font-size: 1.4em;
      font-weight: bold;
      cursor: pointer;
      opacity: 0;
      transition: all 0.3s ease;
      z-index: 10;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 8px rgba(0,0,0,0.4);
      backdrop-filter: blur(4px);
    }

    /* Hover behavior for desktop */
    @media (hover: hover) {
      .upload-container:hover .remove-photo-btn.show {
        opacity: 1;
      }
      
      .remove-photo-btn.show {
        opacity: 0;
      }
      
      .remove-photo-btn:hover {
        background: rgba(0, 0, 0, 1);
        transform: scale(1.1);
        box-shadow: 0 4px 12px rgba(0,0,0,0.6);
      }
    }

    /* Touch behavior for mobile */
    @media (hover: none) {
      .remove-photo-btn.show {
        opacity: 1;
      }
      
      .remove-photo-btn:active {
        background: rgba(0, 0, 0, 1);
        transform: scale(0.95);
      }
    }

    .continue-btn {
      background: linear-gradient(135deg, #a3d5ff 0%, rgba(255, 255, 255, 0.9) 100%);
      color: #fff;
      border: none;
      padding: 15px 30px;
      margin: 20px 0;
      border-radius: 30px;
      font-size: 1.1em;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 2px;
      cursor: pointer;
      transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      width: 100%;
      display: none;
      position: relative;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(163, 213, 255, 0.4);
      touch-action: manipulation;
      text-align: center;
      opacity: 0;
      transform: translateY(20px);
    }

    .continue-btn.show {
      display: block;
      animation: fadeInUp 0.6s ease-out forwards;
    }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .continue-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, 
          transparent, 
          rgba(255, 180, 180, 0.35), 
          rgba(255, 200, 160, 0.35), 
          rgba(255, 255, 200, 0.35), 
          rgba(200, 255, 200, 0.4), 
          rgba(200, 230, 255, 0.4), 
          rgba(230, 200, 255, 0.35), 
          rgba(255, 200, 230, 0.35), 
          rgba(255, 255, 255, 0.5),
          transparent);
      opacity: 1;
      z-index: 1;
      animation: glacier-rainbow-sweep 4s infinite;
    }

    .continue-btn.show {
      display: block;
    }

    .continue-btn:hover:not(:disabled) {
      transform: translateY(-5px) scale(1.03);
      box-shadow: 0 20px 40px rgba(163, 213, 255, 0.6);
      background: linear-gradient(135deg, #87ceeb 0%, rgba(255, 255, 255, 0.95) 100%);
    }

    .continue-btn:active:not(:disabled) {
      transform: translateY(-2px) scale(0.98);
      box-shadow: 0 10px 25px rgba(163, 213, 255, 0.4);
    }

    .continue-btn:disabled {
      background: #f5f5f5;
      color: #999;
      border: 1px solid rgba(0, 0, 0, 0.05);
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .continue-btn:disabled::before {
      display: none;
    }



    .result-actions-external {
      display: none;
      gap: 10px;
      justify-content: center;
      margin-top: 15px;
    }

    .result-actions-external.show {
      display: flex;
    }

    .result-actions-external .continue-btn {
      display: block;
      width: auto;
      min-width: 120px;
      padding: 10px 20px;
      margin: 0;
      font-size: 0.9em;
      opacity: 1;
      transform: none;
    }

    .download-circle-btn {
      background: linear-gradient(135deg, #a3d5ff 0%, rgba(255, 255, 255, 0.9) 100%);
      color: #fff;
      border: none;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      position: relative;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(163, 213, 255, 0.4);
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0;
    }

    .download-circle-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, 
          transparent, 
          rgba(255, 180, 180, 0.35), 
          rgba(255, 200, 160, 0.35), 
          rgba(255, 255, 200, 0.35), 
          rgba(200, 255, 200, 0.4), 
          rgba(200, 230, 255, 0.4), 
          rgba(230, 200, 255, 0.35), 
          rgba(255, 200, 230, 0.35), 
          rgba(255, 255, 255, 0.5),
          transparent);
      opacity: 1;
      z-index: 1;
      animation: glacier-rainbow-sweep 4s infinite;
      border-radius: 50%;
    }

    .download-circle-btn:hover:not(:disabled) {
      transform: translateY(-5px) scale(1.1);
      box-shadow: 0 20px 40px rgba(163, 213, 255, 0.6);
      background: linear-gradient(135deg, #87ceeb 0%, rgba(255, 255, 255, 0.95) 100%);
    }

    .download-circle-btn:active:not(:disabled) {
      transform: translateY(-2px) scale(1.05);
      box-shadow: 0 10px 25px rgba(163, 213, 255, 0.4);
    }

    .download-circle-btn svg {
      position: relative;
      z-index: 2;
    }

    .restart-circle-btn {
      background: linear-gradient(135deg, #a3d5ff 0%, rgba(255, 255, 255, 0.9) 100%);
      color: #fff;
      border: none;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      position: relative;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(163, 213, 255, 0.4);
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0;
    }

    .restart-circle-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, 
          transparent, 
          rgba(255, 180, 180, 0.35), 
          rgba(255, 200, 160, 0.35), 
          rgba(255, 255, 200, 0.35), 
          rgba(200, 255, 200, 0.4), 
          rgba(200, 230, 255, 0.4), 
          rgba(230, 200, 255, 0.35), 
          rgba(255, 200, 230, 0.35), 
          rgba(255, 255, 255, 0.5),
          transparent);
      opacity: 1;
      z-index: 1;
      animation: glacier-rainbow-sweep 4s infinite;
      border-radius: 50%;
    }

    .restart-circle-btn:hover:not(:disabled) {
      transform: translateY(-5px) scale(1.1);
      box-shadow: 0 20px 40px rgba(163, 213, 255, 0.6);
      background: linear-gradient(135deg, #87ceeb 0%, rgba(255, 255, 255, 0.95) 100%);
    }

    .restart-circle-btn:active:not(:disabled) {
      transform: translateY(-2px) scale(1.05);
      box-shadow: 0 10px 25px rgba(163, 213, 255, 0.4);
    }

    .restart-circle-btn svg {
      position: relative;
      z-index: 2;
    }

    .share-circle-btn {
      background: linear-gradient(135deg, #a3d5ff 0%, rgba(255, 255, 255, 0.9) 100%);
      color: #fff;
      border: none;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      position: relative;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(163, 213, 255, 0.4);
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0;
    }

    .share-circle-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, 
          transparent, 
          rgba(255, 180, 180, 0.35), 
          rgba(255, 200, 160, 0.35), 
          rgba(255, 255, 200, 0.35), 
          rgba(200, 255, 200, 0.4), 
          rgba(200, 230, 255, 0.4), 
          rgba(230, 200, 255, 0.35), 
          rgba(255, 200, 230, 0.35), 
          rgba(255, 255, 255, 0.5),
          transparent);
      opacity: 1;
      z-index: 1;
      animation: glacier-rainbow-sweep 4s infinite;
      border-radius: 50%;
    }

    .share-circle-btn:hover:not(:disabled) {
      transform: translateY(-5px) scale(1.1);
      box-shadow: 0 20px 40px rgba(163, 213, 255, 0.6);
      background: linear-gradient(135deg, #87ceeb 0%, rgba(255, 255, 255, 0.95) 100%);
    }

    .share-circle-btn:active:not(:disabled) {
      transform: translateY(-2px) scale(1.05);
      box-shadow: 0 10px 25px rgba(163, 213, 255, 0.4);
    }

    .share-circle-btn svg {
      position: relative;
      z-index: 2;
    }

    /* Back to Catalog Button - Simple black arrow */
    .back-to-catalog-btn {
      background: none;
      border: none;
      color: #000;
      font-family: 'Special Elite', monospace;
      font-size: 24px;
      font-weight: normal;
      cursor: pointer;
      padding: 10px;
      margin: 0;
      transition: all 0.3s ease;
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 10;
    }

    .back-to-catalog-btn:hover {
      color: #333;
      transform: translateX(-3px);
    }

    .back-to-catalog-btn:active {
      color: #000;
      transform: translateX(-1px);
    }

    /* Back Circle Button - Same style as other circular buttons */
    .back-circle-btn {
      background: linear-gradient(135deg, #a3d5ff 0%, rgba(255, 255, 255, 0.9) 100%);
      color: #fff;
      border: none;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      position: relative;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(163, 213, 255, 0.4);
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0;
    }

    .back-circle-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, 
          transparent, 
          rgba(255, 180, 180, 0.35), 
          rgba(255, 200, 160, 0.35), 
          rgba(255, 255, 200, 0.35), 
          rgba(200, 255, 200, 0.4), 
          rgba(200, 230, 255, 0.4), 
          rgba(230, 200, 255, 0.35), 
          rgba(255, 200, 230, 0.35), 
          transparent);
      transition: left 0.8s ease;
    }

    .back-circle-btn:hover:not(:disabled)::before {
      left: 100%;
    }

    .back-circle-btn:hover:not(:disabled) {
      transform: translateY(-5px) scale(1.1);
      box-shadow: 0 20px 40px rgba(163, 213, 255, 0.6);
      background: linear-gradient(135deg, #87ceeb 0%, rgba(255, 255, 255, 0.95) 100%);
    }

    .back-circle-btn:active:not(:disabled) {
      transform: translateY(-2px) scale(1.05);
      box-shadow: 0 10px 25px rgba(163, 213, 255, 0.4);
    }

    .back-circle-btn svg {
      position: relative;
      z-index: 2;
    }

    /* Iridescent arrows pointing from product to upload */
    .try-on-arrows {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 1001;
      display: none;
      pointer-events: none;
    }

    .try-on-arrows.show {
      display: block;
    }

    .arrow-top, .arrow-bottom {
      position: absolute;
      opacity: 0;
      transform: scale(0);
      animation: arrowCreate 1.2s ease-out forwards;
      overflow: hidden;
    }

    @keyframes glacier-rainbow-sweep {
      0% { left: -100%; opacity: 0.4; }
      50% { left: 0%; opacity: 0.7; }
      100% { left: -100%; opacity: 0.4; }
    }

    /* Custom arrow sweep animation that fills the arrow progressively */
    @keyframes arrow-rainbow-sweep {
      0% { 
        width: 0%;
        left: 0%;
        opacity: 0;
      }
      10% {
        width: 0%;
        left: 0%;
        opacity: 0.8;
      }
      70% { 
        width: 100%;
        left: 0%;
        opacity: 0.8;
      }
      100% { 
        width: 100%;
        left: 0%;
        opacity: 0;
      }
    }

    .arrow-top::after, .arrow-bottom::after {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, 
          rgba(255, 180, 180, 0.4), 
          rgba(255, 200, 160, 0.4), 
          rgba(255, 255, 200, 0.5), 
          rgba(200, 255, 200, 0.4), 
          rgba(200, 230, 255, 0.5), 
          rgba(230, 200, 255, 0.4), 
          rgba(255, 200, 230, 0.4), 
          rgba(255, 255, 255, 0.7));
      opacity: 0;
      z-index: 2;
      animation: arrow-rainbow-sweep 2s infinite;
      pointer-events: none;
      -webkit-clip-path: path('M52.5 35 Q40 35 40 50 Q40 65 52.5 65 L269.5 65 L269.5 85 L336 50 L269.5 15 L269.5 35 Z');
      clip-path: path('M52.5 35 Q40 35 40 50 Q40 65 52.5 65 L269.5 65 L269.5 85 L336 50 L269.5 15 L269.5 35 Z');
      border-radius: 0;
    }

    .arrow-bottom::after {
      -webkit-clip-path: path('M42 28 Q30 28 30 40 Q30 52 42 52 L210 52 L210 68 L268 40 L210 12 L210 28 Z');
      clip-path: path('M42 28 Q30 28 30 40 Q30 52 42 52 L210 52 L210 68 L268 40 L210 12 L210 28 Z');
    }

    .arrow-top {
      top: -70px;
      left: -120px;
      animation-delay: 0.2s;
    }

    .arrow-bottom {
      top: 10px;
      left: -90px;
      animation-delay: 0.5s;
    }

    .arrow-top svg, .arrow-bottom svg {
      fill: url(#arrow-gradient);
      filter: drop-shadow(0 4px 8px rgba(163, 213, 255, 0.4));
      position: relative;
    }

    @keyframes arrowCreate {
      0% { 
        opacity: 0;
        transform: scale(0) rotate(-10deg);
      }
      50% {
        opacity: 0.7;
        transform: scale(1.1) rotate(2deg);
      }
      100% { 
        opacity: 1;
        transform: scale(1) rotate(0deg);
      }
    }

    /* Hide arrows on mobile */
    @media (max-width: 768px) {
      .try-on-arrows {
        display: none !important;
      }
    }

    .action-btn-small {
      background: #333;
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 20px;
      font-size: 0.9em;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .action-btn-small:hover {
      background: #555;
      transform: translateY(-2px);
    }

    /* Try On Container Animations */
    .modal-content {
      background-color: #fff;
      margin: 5% auto;
      padding: 1.5rem;
      border: 1px solid #888;
      width: 90%;
      max-width: 300px;
      border-radius: 15px;
      text-align: center;
      position: relative;
      animation: fadeInSlide 0.4s ease;
      transition: transform 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }

    /* Mobile: Swipe up animation */
    @media (max-width: 768px) {
      .modal-content.try-on-swipe-up {
        animation: swipeUpMobile 1.2s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
      }
      
      @keyframes swipeUpMobile {
        0% {
          transform: translateY(0);
          opacity: 1;
        }
        100% {
          transform: translateY(-100vh);
          opacity: 0;
        }
      }
    }

    /* Final Result Screen */
    .final-result-screen {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      z-index: 2000;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      opacity: 0;
      transition: opacity 1s ease;
    }

    .final-result-screen.show {
      opacity: 1;
    }

    .final-result-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      max-width: 90%;
      max-height: 90%;
      transform: translateY(50px);
      transition: transform 1s ease;
    }

    .final-result-screen.show .final-result-container {
      transform: translateY(0);
    }

    .final-result-image {
      max-width: 400px;
      max-height: 500px;
      width: auto;
      height: auto;
      border-radius: 15px;
      box-shadow: 0 10px 30px rgba(255, 255, 255, 0.2);
      margin: 20px 0;
    }

    .final-result-actions-top {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
    }

    .final-result-actions-bottom {
      margin-top: 20px;
    }

    .buy-btn {
      background: linear-gradient(135deg, #a3d5ff 0%, rgba(255, 255, 255, 0.9) 100%);
      color: #fff;
      border: none;
      padding: 1rem 2rem;
      cursor: pointer;
      font-size: 1.1rem;
      border-radius: 30px;
      transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      touch-action: manipulation;
      position: relative;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(163, 213, 255, 0.4);
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 2px;
      min-width: 200px;
    }

    .buy-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, 
          transparent, 
          rgba(255, 180, 180, 0.35), 
          rgba(255, 200, 160, 0.35), 
          rgba(255, 255, 200, 0.35), 
          rgba(200, 255, 200, 0.4), 
          rgba(200, 230, 255, 0.4), 
          rgba(230, 200, 255, 0.35), 
          rgba(255, 200, 230, 0.35), 
          rgba(255, 255, 255, 0.5),
          transparent);
      opacity: 1;
      z-index: 1;
      animation: glacier-rainbow-sweep 4s infinite;
    }

    .buy-btn:hover:not(:disabled) {
      transform: translateY(-5px) scale(1.03);
      box-shadow: 0 20px 40px rgba(163, 213, 255, 0.6);
      background: linear-gradient(135deg, #87ceeb 0%, rgba(255, 255, 255, 0.95) 100%);
    }

    .buy-btn:active:not(:disabled) {
      transform: translateY(-2px) scale(0.98);
      box-shadow: 0 10px 25px rgba(163, 213, 255, 0.4);
    }

    @media (max-width: 768px) {
      .final-result-image {
        max-width: 300px;
        max-height: 400px;
      }
      
      .final-result-actions-top {
        gap: 15px;
      }
      
      .buy-btn {
        padding: 0.8rem 1.5rem;
        font-size: 1rem;
        min-width: 150px;
      }
    }

    /* Desktop: Move left and reduce height animation */
    @media (min-width: 769px) {
      .modal-content.try-on-move-left {
        animation: moveLeftAndReduceDesktop 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
      }
      
      @keyframes moveLeftAndReduceDesktop {
        0% {
          transform: translateX(0);
          height: auto;
          min-height: auto;
        }
        100% {
          transform: translateX(-150px);
          height: 380px; /* Balanced height - shows full image with compact white space */
          min-height: 380px;
          overflow: hidden;
        }
      }
    }
    
    /* Media Queries for Responsiveness */
    @media (max-width: 768px) {
      header {
        justify-content: space-between;
        padding: 10px 15px;
      }
    
      /* Hamburger → X transformation (match index/page3 style) */
      .menu-toggle {
        display: block;
        position: fixed;
        top: 20px;
        right: 20px;
        width: 30px;
        height: 22px;
        cursor: pointer;
        z-index: 1001;
        background: transparent;
        border: none;
        padding: 0;
      }
      .menu-toggle span {
        display: block;
        position: absolute;
        height: 3px;
        width: 100%;
        background: black;
        border-radius: 3px;
        opacity: 1;
        left: 0;
        transform: rotate(0deg);
        transform-origin: center;
        transition: all 0.25s ease-in-out;
      }
      .menu-toggle span:nth-child(1) { top: 0; }
      .menu-toggle span:nth-child(2) { top: 9px; }
      .menu-toggle span:nth-child(3) { top: 18px; }
      .menu-toggle.active span:nth-child(1) {
        top: 9px;
        transform: rotate(135deg);
      }
      .menu-toggle.active span:nth-child(2) {
        opacity: 0;
        right: -60px;
      }
      .menu-toggle.active span:nth-child(3) {
        top: 9px;
        transform: rotate(-135deg);
      }
    
      header nav {
        position: fixed;
        top: 0;
        right: -100%;
        width: 80%;
        max-width: 300px;
        height: 100vh;
        background-color: white;
        z-index: 100;
        transition: right 0.3s ease;
        box-shadow: -5px 0 15px rgba(0,0,0,0.1);
        padding: 80px 20px 20px;
      }
      
      header nav.active {
        right: 0;
      }
      
      header nav ul {
        flex-direction: column;
      }
      
      header nav ul li {
        margin-right: 0;
        margin-bottom: 15px;
      }
      
      .basket-desktop { display: none !important; }
      .basket-mobile { display: block !important; }
      #basketDropdown {
        right: 10px !important;
        left: 10px !important;
        min-width: unset !important;
        max-width: 95vw !important;
      }
      
      .products {
        grid-template-columns: repeat(2, 1fr);
        gap: 15px;
        padding: 15px;
      }
      
      .product {
        min-height: 180px;
        padding: 10px;
      }
      
      .image-container {
        height: 150px;
      }
      
      .product-name {
        font-size: 1em;
      }
      
      .product-price {
        font-size: 0.9em;
      }
      
      .modal-content {
        width: 95%;
        max-width: 350px;
        padding: 1rem;
      }
      
      #modalProductImage {
        max-width: 200px;
      }
      
      .proceed-btn {
        padding: 0.8rem 1rem;
        font-size: 0.9rem;
      }
    }
    
    @media (max-width: 480px) {
      .products {
        grid-template-columns: 1fr;
        gap: 10px;
        padding: 10px;
      }
      
      .product {
        min-height: 160px;
        padding: 8px;
      }
      
      .image-container {
        height: 120px;
      }
      
      .product-name {
        font-size: 0.9em;
      }
      
      .product-price {
        font-size: 0.8em;
      }
      
      .main-title {
        font-size: 1.5em;
        margin: 15px 0;
      }
      
      #searchInput {
        width: 95%;
        padding: 8px 12px;
        font-size: 0.9em;
      }
    }
  .result-in-place img, #finalResultImage {
  width: 100%;
  height: auto;
  object-fit: contain;
  image-rendering: auto;
  opacity: 0;
  transition: opacity 160ms ease;
}
.result-in-place.show img, #finalResultScreen.show #finalResultImage {
  opacity: 1;
    }
  </style>
</head>
  <div style="height:3px;background:#eee;transform-origin:left;position:sticky;top:0;left:0;z-index:2000;">
    <div id="aiProgress" style="height:3px;transform:scaleX(0);transition:transform .2s;"></div>
  </div>

  <header>
    <div class="logo">
      <h1>FITRITE</h1>
      <p>Available Leather Jackets</p>
    </div>
    <nav id="mobileNav">
      <ul>
        <li><a href="index.html">HOME</a></li>
        <li><a href="page2.html">FITTING ROOM</a></li>
        <li><a href="page3.html">CHECKOUT</a></li>
        <li class="basket-desktop">
          <button id="basketDropdownBtn" style="background:none;border:none;cursor:pointer;position:relative;">
            🛒
            <span id="basketCount" style="font-size:0.8em;background:#000;color:#fff;border-radius:50%;padding:2px 6px;position:absolute;top:-8px;right:-10px;display:none;width:20px;height:20px;display:flex;align-items:center;justify-content:center;">0</span>
          </button>
          <div id="basketDropdown" style="display:none;position:absolute;right:0;top:40px;min-width:300px;max-width:350px;background:#fff;border:1px solid #ddd;border-radius:15px;box-shadow:0 4px 16px rgba(0,0,0,0.15);z-index:2000;padding:15px 10px 10px 10px;">
            <div id="basketDropdownContent" style="padding-top:20px;">Your basket is empty.</div>
            <div id="basketDropdownFooter" style="margin-top:15px;padding-top:15px;border-top:1px solid #eee;text-align:center;display:none;">
                <button id="clearBasketBtn" style="background:#c00;color:#fff;border:none;padding:8px 16px;border-radius:4px;cursor:pointer;font-family:'Special Elite',monospace;font-size:0.9em;text-transform:uppercase;">Clear Basket</button>
            </div>
          </div>
        </li>
        <li class="basket-mobile" style="display:none;width:100%;">
          <button id="basketDropdownBtnMobile" class="basket-mobile-btn" style="background:none;border:none;cursor:pointer;width:100%;padding:5px 10px;text-align:left;display:block;">
            <span style="font-family:'Special Elite',monospace;font-size:1.2em;letter-spacing:0.04em;vertical-align:middle;">BASKET</span>
            <span id="basketCountMobile" style="font-size:1em;background:#000;color:#fff;border-radius:50%;padding:2px 8px;margin-left:10px;vertical-align:middle;width:24px;height:24px;display:flex;align-items:center;justify-content:center;">0</span>
          </button>
          <div id="basketDropdownMobile" class="basketDropdownMobile">
            <div id="basketDropdownContentMobile" style="padding-top:10px;">Your basket is empty.</div>
            <div id="basketDropdownFooterMobile" style="margin-top:15px;padding-top:15px;border-top:1px solid #eee;text-align:center;display:none;">
                <button id="clearBasketBtnMobile" style="background:#c00;color:#fff;border:none;padding:8px 16px;border-radius:4px;cursor:pointer;font-family:'Special Elite',monospace;font-size:0.9em;text-transform:uppercase;">Clear Basket</button>
            </div>
          </div>
        </li>
      </ul>
    </nav>
    <div class="menu-toggle" id="menuToggle">
      <span></span>
      <span></span>
      <span></span>
    </div>
  </header>

  <div id="search-bar">
    <input type="text" id="searchInput" placeholder="Search leather jackets..." onkeyup="filterProducts()">
  </div>

  <h1 class="main-title">Available Leather Jackets</h1>

  <div class="products" id="products-container">
    <!-- Products will be dynamically loaded here -->
  </div>

  <footer>
    <p>&copy; 2024 Fitrite. All rights reserved.</p>
  </footer>

  <!-- Modal (Pop-up) -->
  <div id="productModal" class="modal">
    <div class="modal-content">
      <span class="close-btn" id="closeModal">&times;</span>
      <img id="modalProductImage" src="" alt="">
      <h3 id="modalProductName" class="fade-out-element"></h3>
      <p id="modalProductPrice" class="fade-out-element"></p>
      <p style="margin: 1rem 0;" class="fade-out-element">Would you like to proceed with this product?</p>
      <button id="addToBasket" class="proceed-btn fade-out-element">Add to Basket</button>
      <button id="proceedToPayment" class="proceed-btn fade-out-element">Go to Payment Page</button>
      <select id="sizeSelector" class="proceed-btn fade-out-element">
        <option value="S">S</option>
        <option value="M" selected>M</option>
        <option value="L">L</option>
        <option value="XL">XL</option>
      </select>
      <button id="tryOnBtn" class="try-on-btn fade-out-element">
        Try On
      </button>
    </div>
  </div>

  <!-- Model Upload Section (Hidden Initially) -->
  <div id="modelUploadSection" class="model-upload-section">
    <div class="upload-container">
      <h2 class="upload-title">CLICK HERE TO ADD YOUR PHOTO</h2>
      <div class="person-upload-area" id="personUploadArea">
        <div class="person-upload-inner" id="personUploadInner">
          <div class="upload-prompt" id="uploadPrompt">
            <div class="upload-icon">
              <svg width="80" height="80" viewBox="0 0 120 120" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                <!-- Flash unit (big flash on top) -->
                <rect x="35" y="5" width="50" height="25" rx="8" ry="8" fill="none"/>
                <rect x="40" y="10" width="40" height="15" rx="4" ry="4" fill="none"/>
                <!-- Flash reflector -->
                <ellipse cx="60" cy="17.5" rx="15" ry="8" fill="none" opacity="0.3"/>
                <!-- Flash connection -->
                <rect x="55" y="30" width="10" height="8" rx="2" ry="2"/>
                
                <!-- Camera body main -->
                <rect x="20" y="38" width="80" height="55" rx="6" ry="6"/>
                <!-- Camera top plate -->
                <rect x="25" y="33" width="70" height="10" rx="3" ry="3"/>
                
                <!-- Viewfinder prism -->
                <rect x="45" y="28" width="30" height="8" rx="2" ry="2"/>
                <rect x="50" y="25" width="20" height="6" rx="2" ry="2"/>
                
                <!-- Main lens mount -->
                <circle cx="60" cy="65" r="22"/>
                <!-- Lens outer ring -->
                <circle cx="60" cy="65" r="18"/>
                <!-- Lens middle ring -->
                <circle cx="60" cy="65" r="14"/>
                <!-- Lens inner -->
                <circle cx="60" cy="65" r="10"/>
                <!-- Lens center -->
                <circle cx="60" cy="65" r="6"/>
                <!-- Lens reflection -->
                <circle cx="57" cy="62" r="3" fill="currentColor" opacity="0.2"/>
                
                <!-- Camera controls -->
                <circle cx="85" cy="45" r="3"/>
                <circle cx="85" cy="55" r="2"/>
                <rect x="82" y="65" width="6" height="4" rx="1"/>
                
                <!-- Brand plate -->
                <rect x="25" y="45" width="25" height="6" rx="1" opacity="0.4"/>
                
                <!-- Camera grip texture -->
                <line x1="25" y1="50" x2="25" y2="85"/>
                <line x1="27" y1="52" x2="27" y2="83"/>
                <line x1="29" y1="54" x2="29" y2="81"/>
                
                <!-- Film advance lever -->
                <path d="M 90 40 Q 95 35 100 40" fill="none"/>
                
                <!-- Hot shoe -->
                <rect x="55" y="30" width="10" height="3" rx="1"/>
              </svg>
            </div>
          </div>
        </div>
        <img id="personPhotoPreview" class="person-photo-preview" alt="Person Preview">
        <div class="result-in-place" id="resultInPlace">
          <img id="resultImageInPlace" class="result-image-in-place" alt="Virtual Try-On Result">
          <button class="result-back-btn" id="resultBackBtn" title="Remove item">←</button>
        </div>
        <div class="processing-overlay-local" id="processingOverlayLocal">
          <div class="processing-content-local">
            <div class="processing-spinner"></div>
            <div class="processing-text" id="processingTextLocal">Connecting to AI servers</div>
            <div class="processing-subtext" id="processingSubtextLocal"></div>
            <div class="progress-bar">
              <div class="progress-fill" id="progressFillLocal"></div>
            </div>
          </div>
        </div>
        <button class="remove-photo-btn" id="removePhotoBtn">×</button>
        <input type="file" id="personFileInput" class="file-input" accept="image/*">
      </div>
    </div>
    <button type="button" class="continue-btn" id="continueBtn" disabled>Activate AI</button>
    <div class="result-actions-external" id="resultActionsExternal">
      <button class="share-circle-btn" id="shareBtnSmall">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
          <polyline points="7 10 12 15 17 10"></polyline>
          <line x1="12" y1="15" x2="12" y2="3"></line>
        </svg>
      </button>
      <button class="restart-circle-btn" id="tryAgainBtnSmall">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
          <polyline points="23 4 23 10 17 10"></polyline>
          <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
        </svg>
      </button>
    </div>
  </div>

  <!-- Try On Arrows -->
  <div id="tryOnArrows" class="try-on-arrows">
    <div class="arrow-top">
      <svg width="350" height="100" viewBox="0 0 350 100" fill="none">
        <defs>
          <linearGradient id="arrow-gradient" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" style="stop-color:#a3d5ff;stop-opacity:1" />
            <stop offset="100%" style="stop-color:rgba(255, 255, 255, 0.9);stop-opacity:1" />
          </linearGradient>
          <clipPath id="arrow-clip-top">
            <path d="M52.5 35 Q40 35 40 50 Q40 65 52.5 65 L269.5 65 L269.5 85 L336 50 L269.5 15 L269.5 35 Z"/>
          </clipPath>
        </defs>
        <!-- Arrow body with rounded left edge -->
        <path d="M30 35 Q15 35 15 50 Q15 65 30 65 L270 65 L270 85 L335 50 L270 15 L270 35 Z" fill="url(#arrow-gradient)" stroke="url(#arrow-gradient)" stroke-width="4" clip-path="url(#arrow-clip-top)"/>
      </svg>
    </div>
    <div class="arrow-bottom">
      <svg width="280" height="80" viewBox="0 0 280 80" fill="none">
        <defs>
          <linearGradient id="arrow-gradient-2" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" style="stop-color:#a3d5ff;stop-opacity:1" />
            <stop offset="100%" style="stop-color:rgba(255, 255, 255, 0.9);stop-opacity:1" />
          </linearGradient>
          <clipPath id="arrow-clip-bottom">
            <path d="M42 28 Q30 28 30 40 Q30 52 42 52 L210 52 L210 68 L268 40 L210 12 L210 28 Z"/>
          </clipPath>
        </defs>
        <!-- Arrow body with rounded left edge -->
        <path d="M24 28 Q12 28 12 40 Q12 52 24 52 L210 52 L210 68 L268 40 L210 12 L210 28 Z" fill="url(#arrow-gradient-2)" stroke="url(#arrow-gradient-2)" stroke-width="3.5" clip-path="url(#arrow-clip-bottom)"/>
      </svg>
    </div>
  </div>

  <!-- Toast Notification -->
  <div id="toast">Product added to basket!</div>

  <!-- Final Result Screen -->
  <div id="finalResultScreen" class="final-result-screen">
    <div class="final-result-container">
      <div class="final-result-actions-top">
        <button class="back-to-catalog-btn" id="backToCatalogBtn">←</button>
        <button class="back-circle-btn" id="finalBackBtn">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
            <path d="m12 19-7-7 7-7"></path>
            <path d="m19 12H5"></path>
          </svg>
        </button>
        <button class="share-circle-btn" id="finalShareBtn">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
            <polyline points="7 10 12 15 17 10"></polyline>
            <line x1="12" y1="15" x2="12" y2="3"></line>
          </svg>
        </button>
        <button class="restart-circle-btn" id="finalTryAgainBtn">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="23 4 23 10 17 10"></polyline>
            <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
          </svg>
        </button>
      </div>
      
      <img id="finalResultImage" class="final-result-image" alt="Final Try-On Result">
      
      <div class="final-result-actions-bottom">
        <button class="buy-btn" id="finalBuyBtn">BUY</button>
      </div>
    </div>
  </div>
  <div id="aiPreviewDisclaimer" class="ai-preview-disclaimer" style="display:none;">Preview is for style visualization. Fit may not correspond to selected size.</div>

  <script>
// Persist Try-On state across viewport changes
window.tryOnActive = window.tryOnActive || false;

    // Enable embed mode when ?embed=1 is present
    (function(){
      try {
        const params = new URLSearchParams(window.location.search);
        if (params.get('embed') === '1') {
          document.documentElement.classList.add('embed');
          document.body.classList.add('embed');
          // Flag to adjust behavior in scripts
          window.EMBED_TRYON = true;
          // Prevent page scroll inside iframe
          document.addEventListener('wheel', (e)=>{ e.stopPropagation(); }, { passive: false });
        }
      } catch {}
    })();
    // Fashn.ai API Handler Module
    class FashnAPIHandler {
      constructor(apiKey) {
        this.apiKey = apiKey;
        this.baseURL = 'https://api.fashn.ai/v1';
        this.maxRetries = 3;
        this.retryDelay = 1000;
      }

      async makeRequest(endpoint, options = {}) {
        const url = `${this.baseURL}${endpoint}`;
        const defaultOptions = {
          headers: {
            'Authorization': `Bearer ${this.apiKey}`,
            'Content-Type': 'application/json',
            ...options.headers
          }
        };

        const requestOptions = { ...defaultOptions, ...options };

        for (let attempt = 1; attempt <= this.maxRetries; attempt++) {
          try {
            console.log(`Attempt ${attempt}/${this.maxRetries} for ${endpoint}`);
            
            const response = await fetch(url, requestOptions);
            
            if (!response.ok) {
              const errorText = await response.text();
              throw new Error(`HTTP ${response.status}: ${errorText}`);
            }

            const data = await response.json();
            console.log('API Response:', data);
            return data;

          } catch (error) {
            console.error(`Error on attempt ${attempt}:`, error);
            
            if (attempt === this.maxRetries) {
              throw error;
            }
            
            await this.delay(this.retryDelay * attempt);
          }
        }
      }

      delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
      }

      async startTryOn(modelImage, garmentImage, options = {}) {
        const requestData = {
          model_name: options.modelVersion || 'tryon-v1.6',
          inputs: {
            model_image: modelImage,
            garment_image: garmentImage,
            category: options.category || 'auto',
            segmentation_free: options.segmentationFree !== false,
            moderation_level: options.moderationLevel || 'conservative'
          }
        };

        console.log('Sending try-on request:', requestData);

        const result = await this.makeRequest('/run', {
          method: 'POST',
          body: JSON.stringify(requestData)
        });

        return result.id;
      }

      async checkStatus(predictionId) {
        const result = await this.makeRequest(`/status/${predictionId}`);
        return result;
      }

            async waitForResult(predictionId, onProgress = null, deadlineAt = null) {
        // Adaptive polling with hard deadline
        const started = performance.now();
        const MAX_ATTEMPTS = 200; // bounded by deadline anyway
        let attempt = 0;
        while (true) {
          attempt++;
          // Check deadline
          const now = performance.now();
          if (deadlineAt && now >= deadlineAt) {
            return { success: false, error: 'SLA exceeded (15s)', metadata: { status: 'timeout', attempts: attempt } };
          }
          // Poll
          try {
            const status = await this.checkStatus(predictionId);
            if (onProgress) {
              // If vendor exposes numeric progress, pass through; else synthesize from attempts and time
              const elapsed = now - started;
              const estProgress = Math.min(0.98, elapsed / 14000); // approach 98% before deadline
              onProgress({ attempt, status: status.status, progress: typeof status.progress === 'number' ? status.progress : estProgress });
            }
            if (status.status === 'completed') {
              return { success: true, output: status.output, metadata: status };
            }
            if (status.status === 'failed') {
              return { success: false, error: status.error || 'Processing failed', metadata: status };
            }
          } catch (err) {
            // continue to wait unless deadline hit
            if (deadlineAt && performance.now() >= deadlineAt) {
              return { success: false, error: 'SLA exceeded (15s)', metadata: null };
            }
          }
          // Delay: fast first 10s, then back off a bit
          const elapsed = performance.now() - started;
          const delay = elapsed < 10000 ? 700 : 1200;
          await this.delay(delay);
          if (attempt >= MAX_ATTEMPTS) {
            return { success: false, error: 'Timeout waiting for result', metadata: null };
          }
        }
      }
    

      async processTryOn(modelImage, garmentImage, options = {}) {
        try {
          const predictionId = await this.startTryOn(modelImage, garmentImage, options);
          const result = await this.waitForResult(predictionId, options.onProgress, options.deadlineAt);
          return result;

        } catch (error) {
          console.error('Error in complete processing:', error);
          return {
            success: false,
            error: error.message,
            metadata: null
          };
        }
      }

      async optimizeImage(imageDataURL, maxWidth = 1536, maxHeight = 1536, quality = 0.92) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          
          img.onload = () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            let { width, height } = img;
            const aspectRatio = width / height;

            if (width > maxWidth || height > maxHeight) {
              if (aspectRatio > 1) {
                width = Math.min(width, maxWidth);
                height = width / aspectRatio;
              } else {
                height = Math.min(height, maxHeight);
                width = height * aspectRatio;
              }
            }

            canvas.width = width;
            canvas.height = height;
            ctx.drawImage(img, 0, 0, width, height);

            canvas.toBlob(
              (blob) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.readAsDataURL(blob);
              },
              'image/jpeg',
              quality
            );
          };

          img.onerror = reject;
          img.src = imageDataURL;
        });
      }
    }

    // Initialize FASHN API
    const FASHN_API_KEY = 'fa-BWEKaWHoO0YD-KDW0kUKgK6eEPOzgKh0M1oC0'; // Real FASHN.AI API key
    
    // Validate API key
    if (!FASHN_API_KEY || FASHN_API_KEY === 'your-fashn-api-key-here') {
      console.warn('⚠️ FASHN.AI API key not configured. Please set FASHN_API_KEY.');
    } else {
      console.log('✅ FASHN.AI API key configured successfully');
    }
    
    const fashnAPI = new FashnAPIHandler(FASHN_API_KEY);

    // Add validation function
    function validateAPIConfiguration() {
      if (!FASHN_API_KEY || FASHN_API_KEY === 'your-fashn-api-key-here') {
        throw new Error('FASHN.AI API key not configured. Please contact support.');
      }
    }
    // Mobile Menu Toggle
    const menuToggle = document.getElementById("menuToggle");
    const mobileNav = document.getElementById("mobileNav");
    
    if (menuToggle && mobileNav) {
      menuToggle.addEventListener("click", () => {
        mobileNav.classList.toggle("active");
      });
      
      // Close mobile menu when clicking outside
      document.addEventListener("click", (event) => {
        if (!event.target.closest("#mobileNav") && !event.target.closest("#menuToggle")) {
          mobileNav.classList.remove("active");
        }
      });
    }
    
    // Filter Products
    function filterProducts() {
      const searchInput = document.getElementById("searchInput").value.toLowerCase();
      const productElements = document.querySelectorAll(".product");
      productElements.forEach((productEl) => {
        const nameText = productEl.querySelector(".product-name")?.textContent.toLowerCase() || "";
        const priceText = productEl.querySelector(".product-price")?.textContent.toLowerCase() || "";
        productEl.style.display = (nameText.includes(searchInput) || priceText.includes(searchInput))
          ? "flex"
          : "none";
      });
    }
    
    // Modal Logic
    const modal = document.getElementById("productModal");
    const closeModalBtn = document.getElementById("closeModal");
    const modalProductImage = document.getElementById("modalProductImage");
    const modalProductName = document.getElementById("modalProductName");
    const modalProductPrice = document.getElementById("modalProductPrice");
    const sizeSelector = document.getElementById("sizeSelector");
    
    function openModal(name, price, imgUrl, isDiscounted = false, originalPrice = null) {
      console.log('openModal called with:', { name, price, imgUrl, isDiscounted, originalPrice });
      // HARD RESET: Try-on must never auto-appear on open
      try { window.tryOnActive = false; } catch (_) {}
      
      modalProductName.textContent = name;
      
      if (isDiscounted && originalPrice) {
        modalProductPrice.innerHTML = `<span class="original-price">${originalPrice}</span> <span class="new-price">${price}</span>`;
      } else {
        modalProductPrice.textContent = price;
      }
      
      modalProductImage.src = imgUrl;
      modalProductImage.alt = name;
      
      // Store current product data for later use (even if we early-return below)
      currentProductData = {
        name: name,
        price: price,
        imgUrl: imgUrl,
        isDiscounted: isDiscounted,
        originalPrice: originalPrice
      };
      
      // If an AI process is already running (flag or storage), enforce full-screen loader
      try {
        if (isProcessing || isProcessingActive()) {
          // Mid-load re-entry: do NOT show overlay until user clicks Try On
          allowProcessingOverlay = false;
          forceFullScreenOverlay = false;
          // Hide overlay node if present
          try {
            const ov = document.getElementById('processingOverlayLocal');
            if (ov) { ov.classList.remove('show'); ov.style.display='none'; ov.style.opacity=''; ov.style.pointerEvents=''; }
            try { tryOnSceneryVisible = false; } catch(_) {}
          } catch(_) {}
          // Keep container visible for user to click Try On (no auto try-on)
          try {
            modal.classList.add('show');
            modal.style.display = 'flex';
            modal.style.opacity = '1';
          } catch(_) {}
          return;
        }
      } catch (_) {}

      modal.classList.add("show");
      modal.style.display = "flex";
      
      console.log('currentProductData set to:', currentProductData);
      
      // Reset fade out elements and container animations when opening modal
      const fadeOutElements = document.querySelectorAll('.fade-out-element');
      const modalContent = document.querySelector('.modal-content');
      
      fadeOutElements.forEach(element => {
        element.classList.remove('hidden');
      });
      
      // Remove any previous animation classes
      modalContent.classList.remove('try-on-swipe-up', 'try-on-container-fadeout');
      // Ensure any inline styles from a previous resize are cleared so the container is visible again
      modalContent.style.opacity = '';
      modalContent.style.pointerEvents = '';
      
      // Remove floating image if exists
      const floatingImage = document.getElementById('floatingProductImage');
      if (floatingImage) {
        floatingImage.remove();
      }
      
      // Reset original image opacity
      const originalImage = document.getElementById('modalProductImage');
      if (originalImage) {
        originalImage.style.opacity = '1';
      }
      
      // Reset and fully hide any try-on UI
      try {
        const arrows = document.getElementById('tryOnArrows');
        if (arrows) arrows.classList.remove('show');
        const modalContentEl = document.querySelector('.modal-content');
        if (modalContentEl) modalContentEl.classList.remove('try-on-swipe-up', 'try-on-container-fadeout');
        const uploadSection = document.getElementById('modelUploadSection');
        if (uploadSection) {
          uploadSection.classList.remove('show', 'scroll-up');
          uploadSection.style.display = 'none';
          uploadSection.style.opacity = '0';
        }
        const processingOverlay = document.getElementById('processingOverlayLocal');
        // Keep overlay active if processing is underway; otherwise reset it
        if (!isProcessing) {
          if (processingOverlay) processingOverlay.classList.remove('show');
          allowProcessingOverlay = false;
        }
        const finalScreen = document.getElementById('finalResultScreen');
        if (finalScreen) { finalScreen.classList.remove('show'); finalScreen.style.display = 'none'; }
        const resultInPlace = document.getElementById('resultInPlace');
        const resultImgInPlace = document.getElementById('resultImageInPlace');
        const resultBackBtn = document.getElementById('resultBackBtn');
        const resultActionsExternal = document.getElementById('resultActionsExternal');
        if (resultInPlace) { resultInPlace.classList.remove('show'); resultInPlace.style.display = 'none'; }
        if (resultImgInPlace) resultImgInPlace.src = '';
        if (resultBackBtn) { resultBackBtn.classList.remove('show'); resultBackBtn.style.display = 'none'; }
        if (resultActionsExternal) { resultActionsExternal.classList.remove('show'); resultActionsExternal.style.display = 'none'; }
        const personPhotoPreview = document.getElementById('personPhotoPreview');
        if (personPhotoPreview) personPhotoPreview.classList.remove('fade-out', 'processing', 'processing-complete');
      } catch (_) {}

      // Hard reset: ensure no try-on UI is visible until user clicks Try On
      try {
        const arrows = document.getElementById('tryOnArrows');
        if (arrows) arrows.classList.remove('show');
        const resultInPlace = document.getElementById('resultInPlace');
        const resultImgInPlace = document.getElementById('resultImageInPlace');
        const resultBackBtn = document.getElementById('resultBackBtn');
        const resultActionsExternal = document.getElementById('resultActionsExternal');
        const personPhotoPreview = document.getElementById('personPhotoPreview');
        if (resultInPlace) { resultInPlace.classList.remove('show'); resultInPlace.style.display = 'none'; }
        if (resultImgInPlace) { resultImgInPlace.src = ''; }
        if (resultBackBtn) { resultBackBtn.classList.remove('show'); resultBackBtn.style.display = 'none'; }
        if (resultActionsExternal) { resultActionsExternal.classList.remove('show'); resultActionsExternal.style.display = 'none'; }
        if (personPhotoPreview) personPhotoPreview.classList.remove('fade-out');
      } catch (_) {}

      // Do not auto-resume here: only resume after user clicks Try On
      // We keep any saved job in storage, and the Try On button handler
      // takes care of resuming or showing the finished result.

      // Ensure Try On button is always enabled and clickable on modal open
      try {
        const tryBtn = document.getElementById('tryOnBtn');
        if (tryBtn) {
          tryBtn.disabled = false;
          tryBtn.style.pointerEvents = 'auto';
        }
      } catch (_) {}
    }
    
    function closeModal() {
      window.tryOnActive = false;
      modal.classList.remove("show");
      // Hide try-on arrows when modal closes
      document.getElementById('tryOnArrows').classList.remove('show');
      
      // Clean up try-on framework elements
      const modelUploadSection = document.getElementById("modelUploadSection");
      const finalResultScreen = document.getElementById("finalResultScreen");
      
      // Fade away model upload section
      if (modelUploadSection) {
        modelUploadSection.classList.remove("show", "scroll-up");
        modelUploadSection.style.transition = "opacity 0.6s ease-out";
        modelUploadSection.style.opacity = "0";
        
        setTimeout(() => {
          modelUploadSection.style.display = "none";
        }, 600);
      }
      
      // Hide final result screen
      if (finalResultScreen.classList.contains("show")) {
        finalResultScreen.classList.remove('show');
        setTimeout(() => {
          finalResultScreen.style.display = 'none';
        }, 1000);
      }
      
      // Remove floating image if exists
      const floatingImage = document.getElementById('floatingProductImage');
      if (floatingImage) {
        floatingImage.remove();
      }
      
      // Reset modal content animations
      const modalContent = document.querySelector('.modal-content');
      if (modalContent) {
        modalContent.classList.remove('try-on-swipe-up', 'try-on-container-fadeout', 'modal-content-hidden');
        // Clear any inline styles so a fresh open starts clean
        modalContent.style.opacity = '';
        modalContent.style.pointerEvents = '';
      }
      
      // Reset fade out elements
      const fadeOutElements = document.querySelectorAll('.fade-out-element');
      fadeOutElements.forEach(element => {
        element.classList.remove('hidden');
      });
      
      // Reset original image opacity
      const originalImage = document.getElementById('modalProductImage');
      if (originalImage) {
        originalImage.style.opacity = '1';
      }
      
      setTimeout(() => { modal.style.display = "none"; }, 400);
      // Do not force-hide overlay if an AI job is running; keep loader persistent
      try {
        if (!isProcessing) {
        const ov = document.getElementById('processingOverlayLocal');
        if (ov) {
          ov.classList.remove('show');
          ov.style.opacity = '';
          ov.style.pointerEvents = '';
        }
        if (typeof allowProcessingOverlay !== 'undefined') allowProcessingOverlay = false;
        if (typeof overlayOriginalParent !== 'undefined') {
          const node = document.getElementById('processingOverlayLocal');
          if (node && overlayOriginalParent && node.parentElement === document.body) {
            overlayOriginalParent.appendChild(node);
            }
          }
        }
      } catch(_) {}
    }
    closeModalBtn.onclick = () => closeModal();
    
    // Close modal when clicking outside modal content
    // BUT ignore clicks on the try-on framework overlays/buttons
    modal.addEventListener("click", (event) => {
      const clickedInsideModalContent = event.target.closest(".modal-content");
      const clickedInTryOnOverlay = event.target.closest('#modelUploadSection') || event.target.closest('#resultActionsExternal') || event.target.closest('#continueBtn');
      if (!clickedInsideModalContent && !clickedInTryOnOverlay) {
        closeModal();
        try {
          const ov = document.getElementById('processingOverlayLocal');
          if (ov) ov.classList.remove('show');
          if (typeof allowProcessingOverlay !== 'undefined') allowProcessingOverlay = false;
        } catch(_) {}
      }
    });
    
    // Close modal when clicking outside modal content (duplicate listener safeguard)
    modal.addEventListener("click", (event) => {
      const clickedInsideModalContent = event.target.closest(".modal-content");
      const clickedInTryOnOverlay = event.target.closest('#modelUploadSection') || event.target.closest('#resultActionsExternal') || event.target.closest('#continueBtn');
      if (!clickedInsideModalContent && !clickedInTryOnOverlay) {
        closeModal();
        try {
          const ov = document.getElementById('processingOverlayLocal');
          if (ov) ov.classList.remove('show');
          if (typeof allowProcessingOverlay !== 'undefined') allowProcessingOverlay = false;
        } catch(_) {}
      }
    });
    
    // Firebase Cart Integration
    let currentProductData = null;
    
    // Function to extract product data from modal
    function extractProductFromModal() {
      const name = modalProductName.textContent;
      
      // Improved price extraction logic for Firebase
      let price;
      const priceElement = modalProductPrice.querySelector(".new-price");
      if (priceElement) {
        // If there's a discounted price element, use it
        price = priceElement.textContent;
      } else {
        // For non-discounted items, get the full text content
        price = modalProductPrice.textContent.trim();
      }
      
      const imgUrl = modalProductImage.src;
      const selectedSize = sizeSelector.value;
      
      // Convert price to cents (preserve decimals)
      const numericPrice = parseFloat(price.replace(/[£,]/g, ''));
      const priceInCents = Number.isFinite(numericPrice) ? Math.round(numericPrice * 100) : 0;
      
      // Create a consistent ID based on name and size to prevent duplicates
      const consistentId = `leather_jacket_${name.replace(/[^a-zA-Z0-9]/g, '_')}_${selectedSize.replace(/[^a-zA-Z0-9]/g, '_')}`;
      
      return {
        id: consistentId,
        name: name,
        price: priceInCents,
        image: imgUrl,
        category: 'leather_jackets',
        selectedSize: selectedSize
      };
    }
    
    // Firebase cart function
    async function addToBasketFirebase() {
      try {
        if (!window.FitRightFirebase) {
          console.error('FitRightFirebase not loaded');
          return;
        }
        
        const productData = extractProductFromModal();
        
        // Check if item already exists in cart
        const cartItems = window.FitRightFirebase.getCartItems();
        const existingItem = cartItems.find(item => 
          item.name === productData.name && 
          item.selectedSize === productData.selectedSize
        );
        
        if (existingItem) {
          // Update quantity of existing item
          await window.FitRightFirebase.updateQuantity(existingItem.id || existingItem.productId, (existingItem.quantity || 1) + 1);
          showToast("Product quantity updated in basket!");
        } else {
          // Add new item
          await window.FitRightFirebase.addProductToCart(productData, 1);
          showToast("Product added to basket!");
        }
        
        closeModal();
      } catch (error) {
        console.error('Error adding to cart:', error);
        showToast("Error adding to basket!");
      }
    }
    
    // Basket Handling & Toast Notification
    function addToBasket(name, price, imgUrl, size, showMessage = true) {
      let basket = JSON.parse(localStorage.getItem("basket")) || [];
      const existingIndex = basket.findIndex(item => item.name === name);
      if (existingIndex !== -1) {
        const item = basket[existingIndex];
        item.quantity = (item.quantity || 1) + 1;
        localStorage.setItem("basket", JSON.stringify(basket));
        
        // Update global basket variable
        window.basket = basket;
        
        // Immediately update the basket counter
        const totalCount = basket.reduce((sum, item) => sum + (item.quantity || 1), 0);
        basketCount.textContent = totalCount;
        basketCount.style.display = 'inline-block';
        if (basketCountMobile) {
          basketCountMobile.textContent = totalCount;
          basketCountMobile.style.display = 'inline-block';
        }
        
        updateBasketDropdown();
        if (showMessage) showToast("Product quantity updated in basket!");
      } else {
        basket.push({ name, newPrice: price, imgUrl, size, quantity: 1 });
        localStorage.setItem("basket", JSON.stringify(basket));
        
        // Update global basket variable
        window.basket = basket;
        
        // Immediately update the basket counter
        const totalCount = basket.reduce((sum, item) => sum + (item.quantity || 1), 0);
        basketCount.textContent = totalCount;
        basketCount.style.display = 'inline-block';
        if (basketCountMobile) {
          basketCountMobile.textContent = totalCount;
          basketCountMobile.style.display = 'inline-block';
        }
        
        updateBasketDropdown();
        if (showMessage) showToast("Product added to basket!");
      }
    }
    
    document.getElementById("addToBasket").onclick = function () {
      // Use Firebase if available, otherwise fallback to localStorage
      if (window.FitRightFirebase) {
        addToBasketFirebase();
        closeModal();
      } else {
        const name = modalProductName.textContent;
        
        // Improved price extraction logic
        let price;
        const priceElement = modalProductPrice.querySelector(".new-price");
        if (priceElement) {
          // If there's a discounted price element, use it
          price = priceElement.textContent;
        } else {
          // For non-discounted items, get the full text content
          price = modalProductPrice.textContent.trim();
        }
        
        const selectedSize = sizeSelector.value;
        
        // Get the image path from the current product data (always use catalog image)
        let imgUrl = '';
        if (currentProductData && currentProductData.imgUrl) {
          imgUrl = currentProductData.imgUrl;
          console.log('Using currentProductData.imgUrl:', imgUrl);
        } else {
          // Fallback to modal image src
          imgUrl = modalProductImage.src;
          console.log('Using modalProductImage.src:', imgUrl);
        }
        
        // Debug: Log the image URL being added to basket
        console.log('Adding to basket:', { name, price, imgUrl, selectedSize });
        
        // Always use the original catalog image path without modifications
        addToBasket(name, price, imgUrl, selectedSize, true);
        closeModal();
      }
    };
    
    document.getElementById("proceedToPayment").onclick = function() {
      const name = modalProductName.textContent;
      
      // Improved price extraction logic for proceed to payment
      let price;
      const priceElement = modalProductPrice.querySelector(".new-price");
      if (priceElement) {
        // If there's a discounted price element, use it
        price = priceElement.textContent;
      } else {
        // For non-discounted items, get the full text content
        price = modalProductPrice.textContent.trim();
      }
      
      const imageUrl = modalProductImage.src;
      const selectedSize = sizeSelector.value;
      const queryString = `?name=${encodeURIComponent(name)}&price=${encodeURIComponent(price)}&imgUrl=${encodeURIComponent(imageUrl)}&size=${encodeURIComponent(selectedSize)}`;
      window.location.href = "page3.html" + queryString;
    };

    // Try On Button Functionality
    document.getElementById('tryOnBtn').addEventListener('click', async function() {
      window.tryOnActive = true;
      // Scoped resume per product on Try On click
      try {
        const key = getCurrentProductKey();
        const job = key && loadJob(key);
        if (job && job.status === 'inflight') {
          if (job.predictionId) {
            // Ensure the user immediately sees the loader on second run
            try { hasActivatedAI = true; isProcessing = true; } catch(_) {}
            // On Try On click (resume), now reveal the environment and floating image
            try { tryOnSceneryVisible = true; } catch(_) {}
            try { showModelUpload(); } catch(_) {}
            try { applyTryOnLayout(); } catch(_) {}
            try { ensureTryOnConsistency(); } catch(_) {}
            try { ensureFloatingProductVisible(); } catch(_) {}
            try { showProcessingFullScreen(); } catch(_) {}
            return resumePrediction(job);
          } else {
            // Invalid/legacy job record: clear and proceed with fresh flow
            clearJob(key);
          }
        }
        // If a previous job already finished, do not auto-show it again.
        // Clear the saved job and proceed with a fresh try-on experience.
        if (job && job.status === 'done') {
          clearJob(key);
        }
      } catch (_) {}
      // First: Fade out all elements
      const fadeOutElements = document.querySelectorAll('.fade-out-element');
      fadeOutElements.forEach(element => {
        element.classList.add('hidden');
      });

      // After fade out delay, start container animations
      setTimeout(() => {
        const modalContent = document.querySelector('.modal-content');
        const productImage = document.getElementById('modalProductImage');
        
        if (window.innerWidth <= 768) {
          // Mobile: Swipe up animation
          modalContent.classList.add('try-on-swipe-up');
        } else {
          // Desktop: Extract image first, then fade out container
          if (productImage) {
            // Get current position and size of image
            const imageRect = productImage.getBoundingClientRect();
            const modalRect = document.getElementById('productModal').getBoundingClientRect();
            
            // Clone the image and position it absolutely
            const imageClone = productImage.cloneNode(true);
            imageClone.id = 'floatingProductImage';
            imageClone.style.position = 'fixed';
            imageClone.style.left = imageRect.left + 'px';
            imageClone.style.top = imageRect.top + 'px';
            imageClone.style.width = imageRect.width + 'px';
            imageClone.style.height = imageRect.height + 'px';
            imageClone.style.zIndex = '1003';
            imageClone.style.transition = 'all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
            imageClone.style.borderRadius = '15px';
            imageClone.style.boxShadow = '0 8px 32px rgba(0, 0, 0, 0.15)';
            imageClone.style.objectFit = 'contain';
            
            // Add clone to body
            document.body.appendChild(imageClone);
            
            // Hide original image
            productImage.style.opacity = '0';
            
            // Animate clone to left position after a short delay
            setTimeout(() => {
              const leftX = modalRect.left + modalRect.width * 0.25; // Adjust for horizontal alignment
              const centerY = modalRect.top + modalRect.height / 2; // Same vertical center as upload container
              
              imageClone.style.left = leftX + 'px';
              imageClone.style.top = centerY + 'px';
              imageClone.style.width = '300px';
              imageClone.style.height = 'auto'; // Let height adjust naturally
              imageClone.style.transform = 'translate(0, -50%)'; // Center vertically
            }, 100);
          }
          
          // Container fade out
          modalContent.classList.add('try-on-container-fadeout');
        }

        // Show model upload section after container animation
        setTimeout(() => {
          showModelUpload();
      try { fetch('https://api.fashn.ai/v1/', { mode: 'no-cors', keepalive: true }); } catch (e) {}
        }, 600);
      }, 700);
    });

    // Final Result Screen Event Listeners
    function restartTryOnFromFinal() {
      try { hideProcessing(); } catch(_) {}
      try { hasActivatedAI = false; hasProcessingCompleted = false; isProcessing = false; markProcessingActive(false); } catch(_) {}
      try { allowProcessingOverlay = false; forceFullScreenOverlay = false; } catch(_) {}
      try { hideResultInPlace(); } catch(_) {}
      // Ensure upload slot is blank (no previous person photo)
      try {
        personFile = null;
        const personPhotoPreview = document.getElementById('personPhotoPreview');
        const removeBtn = document.getElementById('removePhotoBtn');
        const uploadContainer = document.querySelector('.upload-container');
        const personUploadArea = document.getElementById('personUploadArea');
        const uploadPrompt = document.getElementById('uploadPrompt');
        const uploadTitle = document.querySelector('.upload-title');
        const personUploadInner = document.getElementById('personUploadInner');
        if (personPhotoPreview) { personPhotoPreview.classList.remove('show','fade-out'); personPhotoPreview.style.display='none'; personPhotoPreview.src=''; }
        if (removeBtn) removeBtn.classList.remove('show');
        if (uploadContainer) uploadContainer.classList.remove('has-photo');
        if (personUploadArea) personUploadArea.classList.remove('has-photo');
        if (uploadPrompt) { uploadPrompt.classList.remove('hidden'); uploadPrompt.style.display='block'; uploadPrompt.style.opacity='1'; }
        if (uploadTitle) { uploadTitle.style.display='block'; uploadTitle.style.opacity='1'; }
        if (personUploadInner) { personUploadInner.classList.remove('hidden'); personUploadInner.style.opacity='1'; }
        const fileInput = document.getElementById('personFileInput');
        if (fileInput) fileInput.value='';
      } catch(_) {}
      // Reopen modal with the same product and simulate first Try On click
      try {
        const pd = currentProductData || {
          name: (document.getElementById('modalProductName')?.textContent || '').trim(),
          price: (document.getElementById('modalProductPrice')?.textContent || '').trim(),
          imgUrl: document.getElementById('modalProductImage')?.src || '',
          isDiscounted: false,
          originalPrice: null
        };
        if (pd && pd.name && pd.imgUrl) {
          openModal(pd.name, pd.price, pd.imgUrl, pd.isDiscounted, pd.originalPrice);
          // Ensure modal/backdrop is fully visible (background darkening)
          try {
            const modalEl = document.getElementById('productModal');
            if (modalEl) {
              modalEl.classList.add('show');
              modalEl.style.display = 'flex';
              modalEl.style.opacity = '1';
            }
          } catch(_) {}
          // Mimic first-time Try On flow
          setTimeout(() => {
            try {
              const fadeOutEls = document.querySelectorAll('.fade-out-element');
              fadeOutEls.forEach(el => el.classList.add('hidden'));
            } catch(_) {}
            const tryBtn = document.getElementById('tryOnBtn');
            if (tryBtn) tryBtn.click();
          }, 120);
        }
      } catch(_) {}
    }

    document.getElementById('finalTryAgainBtn').addEventListener('click', restartTryOnFromFinal);
    document.getElementById('finalShareBtn').addEventListener('click', downloadResult);
    document.getElementById('finalBuyBtn').addEventListener('click', buyProduct);
    document.getElementById('backToCatalogBtn').addEventListener('click', returnToCatalogue);
    document.getElementById('finalBackBtn').addEventListener('click', returnToCatalogue);
    // Also allow clicking the image itself to download the currently displayed result
    try {
      const finalImgForClick = document.getElementById('finalResultImage');
      if (finalImgForClick) {
        finalImgForClick.style.cursor = 'pointer';
        finalImgForClick.addEventListener('click', downloadResult);
      }
    } catch(_) {}

    // Small Result Buttons Event Listeners
    document.getElementById('tryAgainBtnSmall').addEventListener('click', function() {
      // Return to post-try-on-click environment for a new upload
      hideResultInPlace();
        removePersonPhoto();
      showModelUpload();
    });
    document.getElementById('shareBtnSmall').addEventListener('click', downloadResult);
    // Enable click-to-download on the in-place image too
    try {
      const inPlaceImgForClick = document.getElementById('resultImageInPlace');
      if (inPlaceImgForClick) {
        inPlaceImgForClick.style.cursor = 'pointer';
        inPlaceImgForClick.addEventListener('click', downloadResult);
      }
    } catch(_) {}

    // Other Event Listeners
    document.getElementById('resultBackBtn').addEventListener('click', toggleResultView);
    document.getElementById('continueBtn').addEventListener('click', function(e) {
      e.preventDefault();
      e.stopPropagation();
      startTryOn();
    });

    // Model Upload Functionality
    let personFile = null;
    // ======== FAST MODE & CACHES ========
    const FAST_MODE = true; // prioritize perceived speed
    let cachedPersonBase64 = null;
    let cachedProductBase64 = null;
    let cachedProductFile = null;

    // Check WebP support for better compression
    function browserSupportsWebP() {
      try {
        const cnv = document.createElement('canvas');
        return !!(cnv.getContext && cnv.toDataURL('image/webp').indexOf('data:image/webp') === 0);
      } catch (e) { return false; }
    }

    async function downscaleImageToBlob(file, maxDim = 1280, quality = 0.85) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement('canvas');
          let w = img.width, h = img.height;
          if (w > h && w > maxDim) { h = Math.round(h * maxDim / w); w = maxDim; }
          else if (h >= w && h > maxDim) { w = Math.round(w * maxDim / h); h = maxDim; }
          canvas.width = w; canvas.height = h;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0, w, h);
          const mime = browserSupportsWebP() ? 'image/webp' : 'image/jpeg';
          canvas.toBlob((blob) => {
            if (!blob) return reject(new Error('Compression failed'));
            resolve(blob);
          }, mime, quality);
        };
        img.onerror = reject;
        const fr = new FileReader();
        fr.onload = () => { img.src = fr.result; };
        fr.onerror = reject;
        fr.readAsDataURL(file);
      });
    }

    async function blobToBase64(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }

    // Lightweight, client-side enhancement to aid segmentation and speed up the AI
    // Optimized to favor GPU filters and avoid heavy CPU loops on large images
    const __enhancementCache = Object.create(null);
    async function enhanceForSegmentation(imageDataURL, options = {}) {
      const isModel = (options.kind || 'model') === 'model';
      const cacheKey = options.cacheKey || (isModel ? null : imageDataURL);
      if (cacheKey && __enhancementCache[cacheKey]) return __enhancementCache[cacheKey];
      return new Promise((resolve) => {
        try {
          const img = new Image();
          img.decoding = 'async';
          img.onload = () => {
            // Work at a capped resolution for speed
            const maxDim = 1024;
            let w = img.width, h = img.height;
            if (w > h && w > maxDim) { h = Math.round(h * maxDim / w); w = maxDim; }
            else if (h >= w && h > maxDim) { w = Math.round(w * maxDim / h); h = maxDim; }

            const cnv = document.createElement('canvas');
            cnv.width = w; cnv.height = h;
            const ctx = cnv.getContext('2d');

            // Quick contrast sampling to adapt strength
            let contrastSample = 0;
            try {
              const tmp = document.createElement('canvas');
              tmp.width = 64; tmp.height = 64;
              const tctx = tmp.getContext('2d');
              tctx.drawImage(img, 0, 0, 64, 64);
              const data = tctx.getImageData(0, 0, 64, 64).data;
              let mean = 0; const N = data.length / 4;
              for (let i = 0; i < data.length; i += 4) mean += (data[i] + data[i+1] + data[i+2]) / 3;
              mean /= N;
              let varsum = 0;
              for (let i = 0; i < data.length; i += 4) {
                const g = (data[i] + data[i+1] + data[i+2]) / 3;
                const d = g - mean; varsum += d * d;
              }
              contrastSample = Math.sqrt(varsum / N) / 255; // 0..1
            } catch (_) {}

            // Adaptive GPU filter strengths
            const baseC = isModel ? 1.15 : 1.08;
            const baseB = isModel ? 1.06 : 1.03;
            const baseS = isModel ? 1.06 : 1.03;
            const weaken = Math.min(1, Math.max(0.7, 1 - contrastSample * 0.5));
            ctx.filter = `contrast(${(baseC*weaken).toFixed(3)}) brightness(${(baseB*weaken).toFixed(3)}) saturate(${(baseS).toFixed(3)})`;
            ctx.drawImage(img, 0, 0, w, h);

            // Optional small sharpen only for smaller images (<= 1.2MP)
            try {
              if (w * h <= 1200 * 1000) {
                const imageData = ctx.getImageData(0, 0, w, h);
                const src = imageData.data;
                const out = new Uint8ClampedArray(src.length);
                const idx = (x, y) => (y * w + x) * 4;
                const kernel = [0, -1, 0, -1, 5, -1, 0, -1, 0];
                for (let y = 1; y < h - 1; y++) {
                  for (let x = 1; x < w - 1; x++) {
                    let r = 0, g = 0, b = 0, k = 0;
                    for (let ky = -1; ky <= 1; ky++) {
                      for (let kx = -1; kx <= 1; kx++) {
                        const p = idx(x + kx, y + ky); const kv = kernel[k++];
                        r += src[p] * kv; g += src[p + 1] * kv; b += src[p + 2] * kv;
                      }
                    }
                    const o = idx(x, y);
                    out[o] = Math.max(0, Math.min(255, r));
                    out[o + 1] = Math.max(0, Math.min(255, g));
                    out[o + 2] = Math.max(0, Math.min(255, b));
                    out[o + 3] = src[o + 3];
                  }
                }
                const blendAmt = isModel ? 0.25 : 0.2;
                for (let i = 0; i < src.length; i += 4) {
                  src[i] = src[i] * (1 - blendAmt) + out[i] * blendAmt;
                  src[i + 1] = src[i + 1] * (1 - blendAmt) + out[i + 1] * blendAmt;
                  src[i + 2] = src[i + 2] * (1 - blendAmt) + out[i + 2] * blendAmt;
                }
                ctx.putImageData(imageData, 0, 0);
              }
            } catch (_) {}

            const outUrl = cnv.toDataURL('image/jpeg', isModel ? 0.9 : 0.88);
            if (cacheKey) __enhancementCache[cacheKey] = outUrl;
            resolve(outUrl);
          };
          img.onerror = () => resolve(imageDataURL);
          img.src = imageDataURL;
        } catch (_) {
          resolve(imageDataURL);
        }
      });
    }

    async function ensureResultImageReady(url) {
      try {
        if (!url) return null;
        const img = new Image();
        img.decoding = 'sync';
        img.loading = 'eager';
        // Give the browser a strong hint
        try { img.fetchPriority = 'high'; } catch (e) {}
        img.crossOrigin = 'anonymous';
        img.src = url;
        if (img.decode) {
          await img.decode().catch(() => {});
        } else {
          await new Promise(res => { if (img.complete) res(); else img.onload = () => res(); });
        }
        return url;
      } catch (e) {
        return url; // fall back to immediate show if decode fails
      }
    }

    async function prefetchCurrentProductImage() {
      try {
        const productImage = document.getElementById('modalProductImage');
        if (!productImage || !productImage.src) return;
        const resp = await fetch(productImage.src, { mode: 'cors' }).catch(()=>null) || await fetch(productImage.src, { mode: 'no-cors' }).catch(()=>null);
        if (!resp) return;
        const blob = await resp.blob();
        cachedProductFile = new File([blob], 'product.jpg', { type: blob.type || 'image/jpeg' });
        cachedProductBase64 = await blobToBase64(blob);
      } catch (e) {}
    }

    let resultImageUrl = null;
    const RESULT_STORAGE_KEY = 'tryon:lastResultImage';
    let isProcessing = false;
    let overlayEnforcer = null; // reasserts loader visibility while processing
    let floatingEnforcer = null; // keeps left product image visible during full-screen overlay
    let overlayOriginalParent = null; // original DOM parent to restore overlay after processing
    let forceFullScreenOverlay = false; // when true, processing overlay fills viewport
    function getOverlayAnchor() {
      try { if (forceFullScreenOverlay) return null; } catch (_) {}
      // Prefer the user's inserted image first
      const personImg = document.getElementById('personPhotoPreview');
      if (personImg && personImg.src) return personImg;
      const uploadArea = document.getElementById('personUploadArea');
      if (uploadArea) return uploadArea;
      const floating = document.getElementById('floatingProductImage');
      if (floating) return floating;
      return document.getElementById('modalProductImage');
    }
    function positionOverlayToArea(overlayEl) {
      try {
        if (!overlayEl) return;
        const anchor = getOverlayAnchor();
        if (!anchor) {
          overlayEl.style.position = 'fixed';
          overlayEl.style.left = '0px';
          overlayEl.style.top = '0px';
          overlayEl.style.width = '100vw';
          overlayEl.style.height = '100vh';
          return;
        }
        const rect = anchor.getBoundingClientRect();
        const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
        const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
        const left = Math.max(0, Math.min(rect.left, vw));
        const top = Math.max(0, Math.min(rect.top, vh));
        const width = Math.min(rect.width, vw);
        const height = Math.min(rect.height, vh);
        overlayEl.style.position = 'fixed';
        overlayEl.style.left = left + 'px';
        overlayEl.style.top = top + 'px';
        overlayEl.style.width = width + 'px';
        overlayEl.style.height = height + 'px';
      } catch(_) {}
    }
    let hasProcessingCompleted = false;
    let hasActivatedAI = false;
    let allowProcessingOverlay = false; // gate: show loader only after Activate AI click or resume
    // Global processing marker to survive UI resets; used to force full-screen overlay on re-entry
    function markProcessingActive(active) {
      try {
        const store = window.sessionStorage || window.localStorage;
        if (active) store.setItem('tryon:processing', '1');
        else store.removeItem('tryon:processing');
      } catch(_) {}
    }

    // Show try-on scene (left product + right upload) only after explicit Try On click
    let tryOnSceneryVisible = false;
    function isProcessingActive() {
      try {
        const store = window.sessionStorage || window.localStorage;
        return !!store.getItem('tryon:processing');
      } catch(_) { return false; }
    }

    function showProcessingFullScreen() {
      try {
        allowProcessingOverlay = true;
        forceFullScreenOverlay = true;
        showProcessing();
        const ov = document.getElementById('processingOverlayLocal');
        if (ov) {
          if (ov.parentElement !== document.body) {
            overlayOriginalParent = overlayOriginalParent || ov.parentElement;
            document.body.appendChild(ov);
          }
          ov.classList.add('show');
          ov.style.display = 'flex';
          ov.style.opacity = '1';
          ov.style.pointerEvents = 'auto';
          ov.style.position = 'fixed';
          ov.style.left = '0';
          ov.style.top = '0';
          ov.style.width = '100vw';
          ov.style.height = '100vh';
          ov.style.zIndex = '4000';
        }
        // Keep floating product image alive while full-screen loader is up
        try {
          if (floatingEnforcer) clearInterval(floatingEnforcer);
          floatingEnforcer = setInterval(() => {
            if (!allowProcessingOverlay || !forceFullScreenOverlay || (!isProcessing && !isProcessingActive())) {
              clearInterval(floatingEnforcer); floatingEnforcer = null; return;
            }
            if (window.innerWidth > 768) {
              try { ensureFloatingProductVisible(); } catch(_) {}
            }
          }, 220);
        } catch(_) {}
      } catch(_) {}
    }

    // Ensure the product image (left side) is visible while overlay is full-screen
    function ensureFloatingProductVisible() {
      try {
        const existing = document.getElementById('floatingProductImage');
        if (existing) {
          existing.style.display = 'block';
          existing.style.opacity = '1';
          return;
        }

        const modal = document.getElementById('productModal');
        const productImageEl = document.getElementById('modalProductImage');
        const src = (productImageEl && productImageEl.src) || (currentProductData && currentProductData.imgUrl);
        if (!src) return;

        // Temporarily reveal modal to measure target rect (overlay will cover it)
        const prevDisplay = modal.style.display;
        const prevOpacity = modal.style.opacity;
        modal.style.display = 'flex';
        modal.style.opacity = '0';
        const modalRect = modal.getBoundingClientRect();

        const floating = document.createElement('img');
        floating.id = 'floatingProductImage';
        floating.src = src;
        floating.style.position = 'fixed';
        floating.style.zIndex = '1003';
        floating.style.transition = 'all 280ms cubic-bezier(0.25, 0.46, 0.45, 0.94)';
        floating.style.borderRadius = '15px';
        floating.style.boxShadow = '0 8px 32px rgba(0,0,0,0.15)';
        floating.style.objectFit = 'contain';
        document.body.appendChild(floating);

        const targetLeft = modalRect.left + modalRect.width * 0.25;
        const targetTop = modalRect.top + modalRect.height / 2;
        floating.style.left = targetLeft + 'px';
        floating.style.top = targetTop + 'px';
        floating.style.width = '300px';
        floating.style.height = 'auto';
        floating.style.transform = 'translate(0, -50%)';
        floating.style.opacity = '1';

        // Restore modal visibility state (we still keep it hidden during overlay)
        modal.style.display = prevDisplay || 'none';
        modal.style.opacity = prevOpacity || '0';
      } catch(_) {}
    }

    // Scoped resume helpers (per product) – only used when user clicks Try On
    function getCurrentProductKey() {
      try {
        const name = (document.getElementById('modalProductName')?.textContent || '').trim();
        const img = document.getElementById('modalProductImage')?.src || '';
        return encodeURIComponent(name + '|' + img);
      } catch (_) { return ''; }
    }
    function loadJob(key) {
      try { return JSON.parse(localStorage.getItem('tryon:job:' + key) || 'null'); } catch (_) { return null; }
    }
    function saveJob(key, job) {
      try { localStorage.setItem('tryon:job:' + key, JSON.stringify(job)); } catch (_) {}
    }
    function clearJob(key) {
      try { localStorage.removeItem('tryon:job:' + key); } catch (_) {}
    }

    async function resumePrediction(job) {
      try {
        isProcessing = true;
        try { markProcessingActive(true); } catch(_) {}
        // Ensure try-on container is visible before showing overlay
        try { showModelUpload(); } catch (_) {}

        // Hard-hide any previous result UI so we only see the loader while resuming
        try {
          const finalScreen = document.getElementById('finalResultScreen');
          if (finalScreen) { finalScreen.classList.remove('show'); finalScreen.style.display = 'none'; }
          const resultInPlace = document.getElementById('resultInPlace');
          if (resultInPlace) { resultInPlace.classList.remove('show'); resultInPlace.style.display = 'none'; }
          const resultActionsExternal = document.getElementById('resultActionsExternal');
          if (resultActionsExternal) { resultActionsExternal.classList.remove('show'); resultActionsExternal.style.display = 'none'; }
          const resultBackBtn = document.getElementById('resultBackBtn');
          if (resultBackBtn) { resultBackBtn.classList.remove('show'); resultBackBtn.style.display = 'none'; }
          const resultImgInPlace = document.getElementById('resultImageInPlace');
          if (resultImgInPlace) resultImgInPlace.src = '';
          const finalResultImage = document.getElementById('finalResultImage');
          if (finalResultImage) finalResultImage.src = '';
          resultImageUrl = null;
          // Hide the remove photo button and any upload decorations during resume
          const removeBtn = document.getElementById('removePhotoBtn');
          if (removeBtn) { removeBtn.classList.remove('show'); removeBtn.style.display = 'none'; }
          // Remove any floating product image and reset arrows
          const floating = document.getElementById('floatingProductImage');
          if (floating) floating.remove();
          const arrows = document.getElementById('tryOnArrows');
          if (window.innerWidth > 768) {
            if (arrows) arrows.classList.add('show');
            // Recreate first-run visual: floating product image moves to left
            const productImage = document.getElementById('modalProductImage');
            const modal = document.getElementById('productModal');
            if (productImage && modal) {
              try {
                const imageRect = productImage.getBoundingClientRect();
                const modalRect = modal.getBoundingClientRect();
                const imageClone = productImage.cloneNode(true);
                imageClone.id = 'floatingProductImage';
                imageClone.style.position = 'fixed';
                imageClone.style.left = imageRect.left + 'px';
                imageClone.style.top = imageRect.top + 'px';
                imageClone.style.width = imageRect.width + 'px';
                imageClone.style.height = imageRect.height + 'px';
                imageClone.style.zIndex = '1003';
                imageClone.style.transition = 'all 320ms cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                imageClone.style.borderRadius = '15px';
                imageClone.style.boxShadow = '0 8px 32px rgba(0,0,0,0.15)';
                imageClone.style.objectFit = 'contain';
                document.body.appendChild(imageClone);
                const targetLeft = modalRect.left + modalRect.width * 0.25;
                const targetTop = modalRect.top + modalRect.height / 2;
                requestAnimationFrame(() => {
                  imageClone.style.left = targetLeft + 'px';
                  imageClone.style.top = targetTop + 'px';
                  imageClone.style.width = '300px';
                  imageClone.style.height = 'auto';
                  imageClone.style.transform = 'translate(0, -50%)';
                  imageClone.style.opacity = '1';
                });
              } catch(_) {}
            }
            // overlay visibility is now gated by allowProcessingOverlay
          } else {
            if (arrows) arrows.classList.remove('show');
          }
        } catch (_) {}

        allowProcessingOverlay = true;
        try { forceFullScreenOverlay = true; } catch (_) {}
        showProcessing();
        // Hide the product modal so the UI matches first-run processing state
        try {
          const modalEl = document.getElementById('productModal');
          if (modalEl) {
            modalEl.classList.remove('show');
            modalEl.style.display = 'none';
            modalEl.style.opacity = '0';
          }
        } catch (_) {}
        // Show model upload section container so overlay has a host element
        try {
          const modelUploadSection = document.getElementById('modelUploadSection');
          if (modelUploadSection) {
            modelUploadSection.classList.add('show');
            modelUploadSection.style.opacity = '1';
          }
        } catch(_) {}
        // Ensure Execute AI button is hidden/disabled during resume
        try {
          const continueBtn = document.getElementById('continueBtn');
          if (continueBtn) { continueBtn.style.display = 'none'; continueBtn.classList.remove('show'); continueBtn.disabled = true; }
        } catch (_) {}
        const result = await fashnAPI.waitForResult(job.predictionId, (progress) => {
          try {
            const pct = 30 + (progress.progress * 0.6);
            updateProcessing('Connecting to AI servers', `Processing... (${progress.status})`, pct);
          } catch (_) {}
        }, null);

        if (result && result.success && Array.isArray(result.output) && result.output.length > 0) {
          const url = result.output[0];
          saveJob(getCurrentProductKey(), { status: 'done', resultUrl: url });
          await ensureResultImageReady(url);
          hideProcessing();
          resultImageUrl = url;
          showResultInPlace(url);
          try { showFinalResultScreen(url); } catch (_) {}
          clearJob(getCurrentProductKey());
        } else {
          hideProcessing();
          showToast('Processing failed. Please try again.');
          clearJob(getCurrentProductKey());
        }
      } catch (e) {
        try { hideProcessing(); } catch (_) {}
        showToast('Processing error. Please try again.');
        clearJob(getCurrentProductKey());
      } finally {
        isProcessing = false;
      }
    }

    function showModelUpload() {
      // Do not show upload UI/overlay if try-on is not active or modal is hidden
      try {
        const modalElGuard = document.getElementById('productModal');
        if (!window.tryOnActive || !modalElGuard || modalElGuard.style.display === 'none' || !modalElGuard.classList.contains('show')) {
          return;
        }
      } catch(_) {}
      const modelUploadSection = document.getElementById('modelUploadSection');
      // Gate off loader until user explicitly starts or we resume an inflight job
      // Do not disable the overlay if we're already processing; keep it visible
      if (!isProcessing) {
        allowProcessingOverlay = false;
        try { const ov = document.getElementById('processingOverlayLocal'); if (ov) ov.classList.remove('show'); } catch(_) {}
      }
      
      // Reset any inline styles that may have been applied when closing
      modelUploadSection.style.display = '';
      modelUploadSection.style.opacity = '';
      modelUploadSection.style.transition = '';
      
      if (window.innerWidth <= 768) {
        // Mobile: Show with scroll up animation
        modelUploadSection.classList.add('show', 'scroll-up');
      // Prefetch product image for faster AI start
      prefetchCurrentProductImage();
      } else {
        // Desktop: Show with simple slide in animation
        modelUploadSection.classList.add('show');
        // Show try-on arrows only while pre-result try-on UI is visible
        const arrows = document.getElementById('tryOnArrows');
        if (arrows) arrows.classList.add('show');
      }
      
      // GARANTIR que o botão Execute AI apareça se há foto (mas não durante processamento)
      setTimeout(() => {
        if (!isProcessing) {
          ensureExecuteAIButtonVisible();
        }
      }, 100);
    }

    function hideModelUpload() {
      const modelUploadSection = document.getElementById('modelUploadSection');
      modelUploadSection.classList.remove('show', 'scroll-up');
      // Não remove a foto automaticamente - deixa isso para funções específicas
    }

    // Person upload area click
    document.getElementById('personUploadArea').addEventListener('click', () => {
      if (!personFile) {
        document.getElementById('personFileInput').click();
      }
    });

    // File input change
    document.getElementById('personFileInput').addEventListener('change', (e) => {
      if (e.target.files.length > 0) {
        handlePersonFileSelect(e.target.files[0]);
        
        // FALLBACK ADICIONAL: Garantir botão após processamento do arquivo (mas não durante processamento)
        setTimeout(() => {
          if (!isProcessing) {
            ensureExecuteAIButtonVisible();
          }
        }, 1500);
      }
    });

    // Remove photo button
    document.getElementById('removePhotoBtn').addEventListener('click', () => {
      removePersonPhoto();
    });

    // Continue button
    document.getElementById('continueBtn').addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      startTryOn();
    });

    // Result actions
  document.getElementById('shareBtnSmall').addEventListener('click', () => {
      downloadResult();
    });

    document.getElementById('resultBackBtn').addEventListener('click', () => {
      toggleResultView();
    });

    function handlePersonFileSelect(file) {
      if (!validateFile(file)) {
        return;
      }
      
      personFile = file;
      hasProcessingCompleted = false; // Reset processing completed flag when new photo is selected
      console.log('📷 Foto selecionada, garantindo que botão Execute AI apareça...');
      
      const reader = new FileReader();
      reader.onload = (e) => {
        // Fade out the upload prompt and title
        const uploadPrompt = document.getElementById('uploadPrompt');
        const uploadTitle = document.querySelector('.upload-title');
        const personUploadInner = document.getElementById('personUploadInner');
        const uploadContainer = document.querySelector('.upload-container');
        const personUploadArea = document.getElementById('personUploadArea');
        
        // Start fade out animation
        uploadPrompt.style.transition = 'opacity 0.6s ease-out';
        uploadTitle.style.transition = 'opacity 0.6s ease-out';
        personUploadInner.style.transition = 'opacity 0.6s ease-out';
        
        uploadPrompt.style.opacity = '0';
        uploadTitle.style.opacity = '0';
        personUploadInner.style.opacity = '0';
        
        // After fade out, hide elements and show image
        setTimeout(() => {
          uploadPrompt.classList.add('hidden');
          uploadTitle.style.display = 'none';
          personUploadInner.classList.add('hidden');
          
          // Add has-photo classes
          uploadContainer.classList.add('has-photo');
          personUploadArea.classList.add('has-photo');
          
          // Show the image
          const personPhotoPreview = document.getElementById('personPhotoPreview');
          personPhotoPreview.src = e.target.result;
          personPhotoPreview.style.display = 'block';
          
          // Fade in the image
          setTimeout(() => {
            personPhotoPreview.classList.add('show');
            
            // Show remove button
            const removeBtn = document.getElementById('removePhotoBtn');
            removeBtn.classList.add('show');
            
            // GARANTIR QUE O BOTÃO EXECUTE AI SEMPRE APAREÇA
            ensureExecuteAIButtonVisible();
            
          }, 50);
        }, 600);
        
        // FALLBACK: Garantir botão após todas as animações
        setTimeout(() => {
          ensureExecuteAIButtonVisible();
        }, 1000);
      };
      reader.readAsDataURL(file);
      
      // FALLBACK IMEDIATO: Garantir botão mesmo se houver erro no FileReader
      setTimeout(() => {
        if (personFile) {
          ensureExecuteAIButtonVisible();
        }
      }, 100);
    }

    // NOVA FUNÇÃO: Garantir que o botão Execute AI só apareça quando permitido
    function ensureExecuteAIButtonVisible() {
      const continueBtn = document.getElementById('continueBtn');
      
      if (!continueBtn) {
        console.error('❌ Botão continueBtn não encontrado!');
        return;
      }
      
      // Se já ativou, está processando, ou já concluiu: manter oculto
      if (hasActivatedAI || isProcessing || hasProcessingCompleted) {
        continueBtn.style.display = 'none';
        continueBtn.classList.remove('show');
        continueBtn.disabled = true;
        return;
      }
      
      if (personFile) {
        console.log('✅ Garantindo visibilidade do botão Execute AI...');
        
        // Múltiplas verificações para garantir visibilidade
        continueBtn.style.display = 'block';
        continueBtn.style.visibility = 'visible';
        continueBtn.style.opacity = '1';
        continueBtn.classList.add('show');
        continueBtn.classList.remove('hidden');
        continueBtn.disabled = false;
        
        // Verificação final
        setTimeout(() => {
          const isVisible = continueBtn.style.display !== 'none' && 
                           continueBtn.classList.contains('show') && 
                           !continueBtn.disabled;
          
          if (!isVisible && !hasProcessingCompleted && !hasActivatedAI && !isProcessing) {
            continueBtn.style.display = 'block';
            continueBtn.classList.add('show');
            continueBtn.disabled = false;
          }
        }, 100);
        
      } else {
        console.log('❌ Nenhuma foto carregada, escondendo botão Execute AI');
        continueBtn.style.display = 'none';
        continueBtn.classList.remove('show');
        continueBtn.disabled = true;
      }
    }

    function removePersonPhoto() {
      personFile = null;
      hasProcessingCompleted = false; // Reset processing completed flag when photo is removed
      hasActivatedAI = false; // Allow button to appear again after photo removal
      try { localStorage.removeItem(RESULT_STORAGE_KEY); } catch (_) {}
      
      // Hide photo and remove button first
      const personPhotoPreview = document.getElementById('personPhotoPreview');
      const removeBtn = document.getElementById('removePhotoBtn');
      
      personPhotoPreview.classList.remove('show');
      removeBtn.classList.remove('show');
      
      // GARANTIR que o botão Execute AI seja escondido quando não há foto
      ensureExecuteAIButtonVisible();
      
      // After image fades out, restore container and fade in text
      setTimeout(() => {
        // Remove has-photo classes to restore border and container
        document.getElementById('personUploadArea').classList.remove('has-photo');
        document.querySelector('.upload-container').classList.remove('has-photo');
        
        // Hide photo completely
        personPhotoPreview.style.display = 'none';
        personPhotoPreview.src = '';
        
        // Show and fade in upload prompt and title
        const uploadPrompt = document.getElementById('uploadPrompt');
        const uploadTitle = document.querySelector('.upload-title');
        const personUploadInner = document.getElementById('personUploadInner');
        
        uploadPrompt.classList.remove('hidden');
        uploadTitle.style.display = 'block';
        personUploadInner.classList.remove('hidden');
        
        // Start with opacity 0 and fade in
        uploadPrompt.style.opacity = '0';
        uploadTitle.style.opacity = '0';
        personUploadInner.style.opacity = '0';
        
        setTimeout(() => {
          uploadPrompt.style.transition = 'opacity 0.6s ease-in';
          uploadTitle.style.transition = 'opacity 0.6s ease-in';
          personUploadInner.style.transition = 'opacity 0.6s ease-in';
          
          uploadPrompt.style.opacity = '1';
          uploadTitle.style.opacity = '1';
          personUploadInner.style.opacity = '1';
        }, 50);
      }, 800);
    }

    function validateFile(file) {
      const maxSize = 25 * 1024 * 1024; // 25MB
      const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'];

      if (!allowedTypes.includes(file.type)) {
        showToast('Unsupported format. Use PNG, JPG, JPEG or WebP.');
        return false;
      }

      if (file.size > maxSize) {
        showToast('File too large. Maximum 25MB.');
        return false;
      }

      return true;
    }

    async function startTryOn() {
  try {
      if (isProcessing) return;

      if (!personFile) {
        showToast('Please add your photo first.');
        return;
      }

      const continueBtn = document.getElementById('continueBtn');
      if (continueBtn) {
        continueBtn.style.display = 'none';
        continueBtn.classList.remove('show');
      }
    hasActivatedAI = true;

      isProcessing = true;
      try { markProcessingActive(true); } catch(_) {}
      // Persist the product we are processing for robust resume
      try {
        const prod = null;
      } catch(_) {}
      
      allowProcessingOverlay = true;
      showProcessing();
      let overlayShownAt = performance.now();
      // Hard assert overlay visibility immediately after activation
      try {
        const ov = document.getElementById('processingOverlayLocal');
        if (ov) {
          ov.classList.add('show');
          ov.style.opacity = '1';
          ov.style.pointerEvents = 'auto';
        }
      } catch(_) {}

    let resultImageUrlLocal = await processFashnAI();
        
    // Ensure the image is fully decoded before we swap UI
    await ensureResultImageReady(resultImageUrlLocal);
        
        // Ensure loader is visible for at least 600ms
        try {
          const elapsed = performance.now() - overlayShownAt;
          const minVisible = 600;
          if (elapsed < minVisible) {
            await new Promise(res => setTimeout(res, minVisible - elapsed));
          }
        } catch(_) {}
        hideProcessing();
    showResultInPlace(resultImageUrlLocal);
    try { showFinalResultScreen(resultImageUrlLocal); } catch (e) {}
  } catch (err) {
    console.error('startTryOn error:', err);
    try {
      // Ensure loader is visible for at least 600ms even on fast failures
      try {
        const elapsed = (typeof overlayShownAt !== 'undefined' && overlayShownAt) ? (performance.now() - overlayShownAt) : 0;
        const minVisible = 600;
        if (elapsed < minVisible) {
          await new Promise(res => setTimeout(res, minVisible - elapsed));
        }
      } catch(_) {}
      hideProcessing();
    } catch (_) {}
    showToast('Something went wrong while generating your try-on. Please try again.');
      } finally {
        isProcessing = false;
    
    if (typeof ensureExecuteAIButtonVisible === 'function') {
      ensureExecuteAIButtonVisible();
    }
      }
    }

    async function processFashnAI() {
      const SLA_MS = 45000;
      const deadlineAt = performance.now() + SLA_MS;

      updateProcessing('Connecting to AI servers', 'Preparing images...', 10);

      try {
        // Check if API is properly configured - now we have a real key!
        if (!FASHN_API_KEY || FASHN_API_KEY === 'your-fashn-api-key-here') {
          console.warn('FASHN.AI API key not configured, using simulation mode');
          return await simulateAIProcessing();
        }

        console.log('🚀 Using FASHN.AI real API with key:', FASHN_API_KEY.substring(0, 10) + '...');

        // Convert files to base64
        let modelImageBase64 = await fileToBase64(personFile);
        // Invisible enhancement to improve edge/contrast for faster, more stable segmentation
        try { modelImageBase64 = await enhanceForSegmentation(modelImageBase64, { kind: 'model' }); } catch(_) {}
        const productFile = await getCurrentProductImageFile();
        let garmentImageBase64 = await fileToBase64(productFile);
        try { garmentImageBase64 = await enhanceForSegmentation(garmentImageBase64, { kind: 'garment' }); } catch(_) {}

        updateProcessing('Connecting to AI servers', 'Optimizing images...', 20);

        // Optimize images for API
        const optimizedModelImage = await fashnAPI.optimizeImage(modelImageBase64);
        const optimizedGarmentImage = await fashnAPI.optimizeImage(garmentImageBase64);

        updateProcessing('Connecting to AI servers', 'Starting AI processing...', 30);

        console.log('Sending to FASHN.AI:');
        console.log('Model image size:', optimizedModelImage.length);
        console.log('Garment image size:', optimizedGarmentImage.length);

        // Start job explicitly to obtain predictionId for scoped resume
        const predictionId = await fashnAPI.startTryOn(
          optimizedModelImage,
          optimizedGarmentImage,
          { modelVersion: 'tryon-v1.6' }
        );
        try { const key = getCurrentProductKey(); if (key) saveJob(key, { status: 'inflight', predictionId }); } catch (_) {}

        // Wait for result with progress updates
        const result = await fashnAPI.waitForResult(
          predictionId,
          (progress) => {
            try {
              const pct = 30 + (progress.progress * 0.6);
              updateProcessing('Connecting to AI servers', `Processing... (${progress.status})`, pct);
              const key = getCurrentProductKey();
              if (key) saveJob(key, { status: 'inflight', predictionId });
            } catch (_) {}
          },
          deadlineAt
        );

        if (result.success) {
          updateProcessing('Connecting to AI servers', 'Complete!', 100);
          console.log('FASHN.AI result:', result.output);
          
          // FASHN.AI returns an array of URLs, get the first one
          if (result.output && Array.isArray(result.output) && result.output.length > 0) {
            try {
              localStorage.setItem(RESULT_STORAGE_KEY, result.output[0]);
              const key = getCurrentProductKey();
              if (key) saveJob(key, { status: 'done', resultUrl: result.output[0] });
            } catch(_) {}
            return result.output[0];
          } else {
            throw new Error('No output image received from FASHN.AI');
          }
        } else {
          throw new Error(result.error);
        }
      } catch (error) {
        console.error('Error in processFashnAI:', error);
        throw error;
      }
    }

    async function simulateAIProcessing() {
      // Fallback simulation when API is not configured
      for (let i = 30; i <= 100; i += 10) {
        updateProcessing('Connecting to AI servers', 'Simulating AI processing...', i);
        await new Promise(resolve => setTimeout(resolve, 30));
      }
      
      // Return the person's photo as simulation result
      return document.getElementById('personPhotoPreview').src;
    }

    async function fileToBase64(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    async function getCurrentProductImageFile() {
      console.log('🔍 getCurrentProductImageFile() iniciado - versão simplificada');
      
      try {
        const productImage = document.getElementById('modalProductImage');
        console.log('🖼️ modalProductImage element:', productImage);
        console.log('🔗 modalProductImage.src:', productImage?.src);
        
        if (!productImage || !productImage.src) {
          console.error('❌ No product image found in modal');
          throw new Error('No product image found in modal');
        }
        
        const imageUrl = productImage.src;
        console.log('🌐 URL da imagem:', imageUrl);
        
        // 🎯 Método Principal: Proxy CORS confiável
        try {
          console.log('🚀 Usando proxy CORS para contornar restrições...');
          const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(imageUrl)}`;
          console.log('🔗 Proxy URL:', proxyUrl);
          
          const response = await fetch(proxyUrl, {
            method: 'GET',
            headers: {
              'Accept': 'image/*'
            }
          });
          
          console.log('📡 Response status:', response.status);
          console.log('📡 Response ok:', response.ok);
          
          if (response.ok) {
            const blob = await response.blob();
            console.log('✅ Blob criado com sucesso:', blob.size, 'bytes', 'tipo:', blob.type);
            
            // Verifica se é realmente uma imagem
            if (blob.type.startsWith('image/') || blob.size > 1000) {
              const file = new File([blob], 'product.jpg', { type: 'image/jpeg' });
              console.log('✅ File criado com sucesso:', file.name, file.size, 'bytes');
              return file;
            } else {
              console.warn('⚠️ Blob não parece ser uma imagem válida');
            }
          }
        } catch (error) {
          console.warn('⚠️ Proxy falhou:', error.message);
        }
        
        // 🛡️ Método Fallback: Fetch direto (pode funcionar em alguns casos)
        try {
          console.log('🚀 Tentando fetch direto como fallback...');
          const response = await fetch(imageUrl, {
            method: 'GET',
            mode: 'cors',
            headers: {
              'Accept': 'image/*',
              'Cache-Control': 'no-cache'
            }
          });
          
          if (response.ok) {
            const blob = await response.blob();
            console.log('✅ Fetch direto funcionou! Blob:', blob.size, 'bytes');
            return new File([blob], 'product.jpg', { type: 'image/jpeg' });
          }
        } catch (error) {
          console.warn('⚠️ Fetch direto falhou:', error.message);
        }
        
        // 🆘 Último recurso: Criar um arquivo placeholder
        console.log('🆘 Criando arquivo placeholder como último recurso...');
        const canvas = document.createElement('canvas');
        canvas.width = 500;
        canvas.height = 500;
        const ctx = canvas.getContext('2d');
        
        // Desenha um placeholder
        ctx.fillStyle = '#f0f0f0';
        ctx.fillRect(0, 0, 500, 500);
        ctx.fillStyle = '#333';
        ctx.font = '20px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Product Image', 250, 250);
        
        return new Promise((resolve) => {
          canvas.toBlob((blob) => {
            const file = new File([blob], 'product.jpg', { type: 'image/jpeg' });
            console.log('✅ Arquivo placeholder criado:', file.size, 'bytes');
            resolve(file);
          }, 'image/jpeg', 0.9);
        });
        
      } catch (error) {
        console.error('❌ Erro em getCurrentProductImageFile():', error);
        throw new Error('Failed to load product image: ' + error.message);
      }
    }

    function showProcessing() {
      if (!allowProcessingOverlay) { return; }
      const overlayNode = document.getElementById('processingOverlayLocal');
      if (overlayNode) {
        // Reparent to body to avoid clipping; force when full-screen mode is requested
        try {
          const modalElGuard = document.getElementById('productModal');
          const shouldReparent = (typeof forceFullScreenOverlay !== 'undefined' && forceFullScreenOverlay) || (modalElGuard && modalElGuard.classList.contains('show') && modalElGuard.style.display !== 'none');
          if (shouldReparent && overlayNode.parentElement !== document.body) {
            overlayOriginalParent = overlayOriginalParent || overlayNode.parentElement;
            document.body.appendChild(overlayNode);
          }
        } catch(_) {}
        overlayNode.classList.add('show');
        overlayNode.style.display = 'flex';
        overlayNode.style.opacity = '1';
        overlayNode.style.pointerEvents = 'auto';
        overlayNode.style.zIndex = '4000';
        // If full-screen is requested (mid-load re-entry), avoid anchoring first to the image
        if (typeof forceFullScreenOverlay !== 'undefined' && forceFullScreenOverlay) {
          overlayNode.style.position = 'fixed';
          overlayNode.style.left = '0';
          overlayNode.style.top = '0';
          overlayNode.style.width = '100vw';
          overlayNode.style.height = '100vh';
        } else {
        positionOverlayToArea(overlayNode);
        }
        // Ensure overlay keeps following the anchor (photo/upload) while processing
        try {
          if (overlayEnforcer) clearInterval(overlayEnforcer);
          overlayEnforcer = setInterval(() => {
            if (!isProcessing || !allowProcessingOverlay) { clearInterval(overlayEnforcer); overlayEnforcer = null; return; }
            positionOverlayToArea(overlayNode);
          }, 100);
        } catch(_) {}
        // Restart CSS animations (spinner and rainbow sweep) on every show
        try {
          const spinner = overlayNode.querySelector('.processing-spinner');
          if (spinner) {
            spinner.style.animation = 'none';
            // Force reflow
            void spinner.offsetWidth;
            spinner.style.animation = '';
          }
          const pf = document.getElementById('progressFillLocal');
          if (pf && pf.parentNode) {
            const clone = pf.cloneNode(true);
            pf.parentNode.replaceChild(clone, pf);
          }
        } catch(_) {}
        // Ensure container is visible
        try {
          const host = document.getElementById('modelUploadSection');
          if (host) { host.classList.add('show'); host.style.opacity = '1'; host.style.display = 'block'; }
          const panel = document.querySelector('#modelUploadSection .upload-container');
          if (panel) { panel.style.opacity = '1'; }
        } catch(_) {}

        // Positioned over anchor while processing
        // If the upload section is hidden when resuming, make sure it is visible so
        // the overlay has a concrete anchor (prevents overlay drifting).
        try {
          const host = document.getElementById('modelUploadSection');
          if (host && (host.style.display === 'none' || !host.classList.contains('show'))) {
            host.style.display = 'block';
            host.classList.add('show');
            host.style.opacity = '1';
          }
        } catch(_) {}
      }
      // Hide everything except the loader while processing
      try {
        const arrows = document.getElementById('tryOnArrows');
        if (arrows) arrows.classList.remove('show');
        const continueBtn = document.getElementById('continueBtn');
        if (continueBtn) { continueBtn.style.display = 'none'; continueBtn.classList.remove('show'); continueBtn.disabled = true; }
        const removeBtn = document.getElementById('removePhotoBtn');
        if (removeBtn) { removeBtn.classList.remove('show'); removeBtn.style.display = 'none'; }
        const resultInPlace = document.getElementById('resultInPlace');
        if (resultInPlace) { resultInPlace.classList.remove('show'); resultInPlace.style.display = 'none'; }
        const resultBackBtn = document.getElementById('resultBackBtn');
        if (resultBackBtn) { resultBackBtn.classList.remove('show'); resultBackBtn.style.display = 'none'; }
        const resultActionsExternal = document.getElementById('resultActionsExternal');
        if (resultActionsExternal) { resultActionsExternal.classList.remove('show'); resultActionsExternal.style.display = 'none'; }
        // Ensure upload host is visible to prevent overlay drift on reopen
        const host = document.getElementById('modelUploadSection');
        if (host) { host.classList.add('show'); host.style.opacity = '1'; host.style.display = 'block'; }
      } catch(_) {}
      // Aplica blur na imagem da pessoa durante o processamento
      const personPhoto = document.getElementById('personPhotoPreview');
      if (personPhoto) {
        personPhoto.classList.add('processing');
        personPhoto.classList.remove('processing-complete');
      }
      updateProcessing('Connecting to AI servers', '', 0);
      // Ensure overlay cannot be hidden by layout recalculations while processing
      try {
        if (overlayEnforcer) clearInterval(overlayEnforcer);
        overlayEnforcer = setInterval(() => {
          const overlay = document.getElementById('processingOverlayLocal');
          if (!isProcessing || !allowProcessingOverlay) {
            clearInterval(overlayEnforcer); overlayEnforcer = null; return;
          }
          if (overlay && allowProcessingOverlay) {
            overlay.classList.add('show');
            overlay.style.display = 'flex';
            overlay.style.opacity = '1';
            overlay.style.pointerEvents = 'auto';
            // If host is missing (e.g., user toggled UI), temporarily go full-screen
            const host = document.getElementById('modelUploadSection');
            if (!host || host.style.display === 'none') {
              overlay.style.position = 'fixed';
              overlay.style.left = '0';
              overlay.style.top = '0';
              overlay.style.width = '100vw';
              overlay.style.height = '100vh';
            } else {
            positionOverlayToArea(overlay);
            }
            overlay.style.zIndex = '4000';
            // Allow clicks to pass through to modal so user can press Try On
            overlay.style.pointerEvents = 'none';
            // While in full-screen mode, keep the left product image visible
            try {
              if (typeof forceFullScreenOverlay !== 'undefined' && forceFullScreenOverlay && window.innerWidth > 768) {
                ensureFloatingProductVisible();
              }
            } catch(_) {}
            // Reassert animations while enforcing overlay
            try {
              const spinner = overlay.querySelector('.processing-spinner');
              if (spinner) {
                spinner.style.animation = 'none';
                void spinner.offsetWidth;
                spinner.style.animation = '';
              }
            } catch(_) {}
          }
        }, 120);
      } catch(_) {}
    }

    function hideProcessing() {
      allowProcessingOverlay = false;
      try { markProcessingActive(false); } catch(_) {}
      try { forceFullScreenOverlay = false; } catch (_) {}
      const overlay = document.getElementById('processingOverlayLocal');
      if (overlay) {
        overlay.classList.remove('show');
        // Restore to original parent and clean inline styles
        try {
          overlay.style.display = '';
          overlay.style.opacity = '';
          overlay.style.pointerEvents = '';
          overlay.style.position = '';
          overlay.style.left = '';
          overlay.style.top = '';
          overlay.style.width = '';
          overlay.style.height = '';
          overlay.style.zIndex = '';
          if (overlayOriginalParent && overlay.parentElement === document.body) {
            overlayOriginalParent.appendChild(overlay);
          }
        } catch(_) {}
      }
      // Remove blur da imagem da pessoa quando o processamento termina
      const personPhoto = document.getElementById('personPhotoPreview');
      if (personPhoto) {
        personPhoto.classList.remove('processing');
        personPhoto.classList.add('processing-complete');
      }
      try { if (overlayEnforcer) { clearInterval(overlayEnforcer); overlayEnforcer = null; } } catch(_) {}
    }

    function updateProcessing(text, subtext, progress) {
      document.getElementById('processingTextLocal').textContent = text;
      document.getElementById('processingSubtextLocal').textContent = subtext;
      document.getElementById('progressFillLocal').style.width = progress + '%';
      // Reassert overlay visibility on every update
      try {
        if (allowProcessingOverlay) {
          const ov = document.getElementById('processingOverlayLocal');
          if (ov) {
            ov.classList.add('show');
            ov.style.opacity = '1';
            ov.style.pointerEvents = 'auto';
            positionOverlayToArea(ov);
            ov.style.zIndex = '4000';
          }
        }
      } catch(_) {}
    }
    function updateProgress(p) {
      try {
        const bar = document.getElementById('aiProgress');
        if (bar) {
          const v = Math.max(0.05, Math.min(1, typeof p==='number' ? p : 0));
          bar.style.transform = `scaleX(${v})`;
        }
      } catch(e) {}
    }
    
    // Position FITRITE watermark inside the visible image bounds
    function positionWatermarkForImage(imgEl, containerEl, wmEl) {
      try {
        if (!imgEl || !containerEl || !wmEl) return;
        const imgRect = imgEl.getBoundingClientRect();
        const hostRect = containerEl.getBoundingClientRect();
        // Margin from image edges
        const margin = 14;
        // Bottom-right inside the image bounds
        const rightOffset = Math.max(0, (hostRect.right - imgRect.right) + margin);
        const bottomOffset = Math.max(0, (hostRect.bottom - imgRect.bottom) + margin);
        wmEl.style.position = 'absolute';
        wmEl.style.left = '';
        wmEl.style.top = '';
        wmEl.style.right = rightOffset + 'px';
        wmEl.style.bottom = bottomOffset + 'px';
        wmEl.style.transform = '';
      } catch(_) {}
    }

    function ensureWatermarkInsideImage(imgId, containerId) {
      try {
        const img = document.getElementById(imgId);
        const container = document.getElementById(containerId);
        if (!img || !container) return;
        let wm = container.querySelector('.fitrite-watermark');
        if (!wm) {
          wm = document.createElement('div');
          wm.className = 'fitrite-watermark';
          wm.innerHTML = '<div class="fit-line"></div>FITRITE';
          container.appendChild(wm);
        }
        if (!img.complete) {
          img.addEventListener('load', () => positionWatermarkForImage(img, container, wm), { once: true });
        } else {
          positionWatermarkForImage(img, container, wm);
        }
      } catch(_) {}
    }
    


    function showResultInPlace(persistUrl) {
      // Mark processing as completed
      hasProcessingCompleted = true;
      
      // Hide the processing overlay (if still visible)
      hideProcessing();

      // Inject result into the in-place canvas/container and reveal controls
      const resultInPlace = document.getElementById('resultInPlace');
      const resultImg = document.getElementById('resultImageInPlace');
      const personPhotoPreview = document.getElementById('personPhotoPreview');
      const resultBackBtn = document.getElementById('resultBackBtn');
      const resultActionsExternal = document.getElementById('resultActionsExternal');
      const continueBtn = document.getElementById('continueBtn');

      if (continueBtn) {
        // Keep the button hidden/disabled after start, but do not hide the UI
        continueBtn.style.display = 'none';
        continueBtn.classList.remove('show');
      }

      if (resultImg) {
        const urlToUse = persistUrl || window.resultImageUrl || '';
        if (urlToUse) {
          resultImg.src = urlToUse;
          try { window.resultImageUrl = urlToUse; } catch(_) {}
        }
      }

      // Persist result image locally so it survives navigation/reopen
      try {
        const toSave = persistUrl || resultImageUrl;
        if (toSave) localStorage.setItem(RESULT_STORAGE_KEY, toSave);
        
      } catch (_) {}

      // Fade the original photo and show the result overlay within the same framework
      if (personPhotoPreview) {
        personPhotoPreview.classList.add('fade-out');
      }
      if (resultInPlace) {
        resultInPlace.style.display = 'block';
        resultInPlace.classList.add('show');
        // Ensure watermark is inside the image bounds
        try { ensureWatermarkInsideImage('resultImageInPlace', 'resultInPlace'); } catch(_) {}
        // Keep watermark locked to image on resize/orientation changes
        try {
          const img = document.getElementById('resultImageInPlace');
          const wm = resultInPlace.querySelector('.fitrite-watermark');
          if (img && wm) {
            const handler = () => positionWatermarkForImage(img, resultInPlace, wm);
            window.addEventListener('resize', handler);
            const ro = new (window.ResizeObserver || function(cb){ window.addEventListener('resize', cb); })((entries)=>handler());
            try { ro.observe(img); } catch(_) {}
          }
        } catch(_) {}
      }
      if (resultBackBtn) {
        resultBackBtn.style.display = 'block';
        resultBackBtn.classList.add('show');
      }
      if (resultActionsExternal) {
        resultActionsExternal.style.display = 'block';
        resultActionsExternal.classList.add('show');
      }

      // Show AI preview disclaimer for 4 seconds
      try {
        const banner = document.getElementById('aiPreviewDisclaimer');
        if (banner) {
          banner.style.display = 'block';
          banner.classList.add('show');
          setTimeout(() => {
            banner.classList.remove('show');
            setTimeout(() => { banner.style.display = 'none'; }, 400);
          }, 4000);
        }
      } catch(_) {}

      // Do NOT navigate to the separate final result screen automatically anymore.
      // The user stays within the try-on interface and can toggle/remove as needed.
    }

    function showFinalResultScreen(resultUrl) {
      const finalResultScreen = document.getElementById('finalResultScreen');
      const finalResultImage = document.getElementById('finalResultImage');
      const modal = document.getElementById('productModal');
      const modelUploadSection = document.getElementById('modelUploadSection');
      const floatingImage = document.getElementById('floatingProductImage');
      const tryOnArrows = document.getElementById('tryOnArrows');
      const modalContent = document.querySelector('.modal-content');
      const modalProductImageEl = document.getElementById('modalProductImage');
      const resultInPlace = document.getElementById('resultInPlace');
      const resultBackBtn = document.getElementById('resultBackBtn');
      const resultActionsExternal = document.getElementById('resultActionsExternal');
      const personPhotoPreview = document.getElementById('personPhotoPreview');
      
      // Set the result image
      if (resultUrl) { window.resultImageUrl = resultUrl; }
      finalResultImage.src = window.resultImageUrl;
      
      // Immediately fade out any residual try-on structure and product image in the modal
      if (personPhotoPreview) personPhotoPreview.classList.add('fade-out');
      if (resultInPlace) { resultInPlace.classList.remove('show'); resultInPlace.style.display = 'none'; }
      if (resultBackBtn) { resultBackBtn.classList.remove('show'); resultBackBtn.style.display = 'none'; }
      if (resultActionsExternal) { resultActionsExternal.classList.remove('show'); resultActionsExternal.style.display = 'none'; }
      if (modalProductImageEl) { modalProductImageEl.style.transition = 'opacity 300ms ease'; modalProductImageEl.style.opacity = '0'; }
      if (modalContent) modalContent.classList.remove('try-on-swipe-up', 'try-on-container-fadeout');
      
      // Fade out the entire try-on mechanism including floating product image and arrows
      modal.style.transition = 'opacity 1s ease-out';
      modelUploadSection.style.transition = 'opacity 1s ease-out';
      
      if (floatingImage) {
        floatingImage.style.transition = 'opacity 1s ease-out';
        floatingImage.style.opacity = '0';
      }
      
      // Hide try-on arrows when final result is shown (hard guard)
      if (tryOnArrows) tryOnArrows.classList.remove('show');
      try { document.getElementById('tryOnArrows').classList.remove('show'); } catch(_) {}
      
      modal.style.opacity = '0';
      modelUploadSection.style.opacity = '0';
      
      setTimeout(() => {
        modal.style.display = 'none';
        modelUploadSection.style.display = 'none';
        // Ensure arrows remain hidden once final is visible
        try { document.getElementById('tryOnArrows').classList.remove('show'); } catch(_) {}
        
        if (floatingImage) {
          floatingImage.style.display = 'none';
        }
        
        // Show the final result screen centered and full-viewport (hard guard)
        finalResultScreen.style.position = 'fixed';
        finalResultScreen.style.top = '0';
        finalResultScreen.style.left = '0';
        finalResultScreen.style.width = '100%';
        finalResultScreen.style.height = '100%';
        finalResultScreen.style.display = 'flex';
        finalResultScreen.style.alignItems = 'center';
        finalResultScreen.style.justifyContent = 'center';
        
        // Also ensure the inner container is centered regardless of previous transforms
        const container = finalResultScreen.querySelector('.final-result-container');
        if (container) {
          container.style.margin = '0 auto';
        }
        
        setTimeout(() => {
          finalResultScreen.classList.add('show');
        }, 50);

        // Show AI preview disclaimer for 4 seconds when final screen appears
        try {
          const banner = document.getElementById('aiPreviewDisclaimer');
          if (banner) {
            banner.style.display = 'block';
            banner.classList.add('show');
            setTimeout(() => {
              banner.classList.remove('show');
              setTimeout(() => { banner.style.display = 'none'; }, 400);
            }, 4000);
          }
        } catch(_) {}

        // Inject watermark into final screen
        try {
          const container = document.querySelector('#finalResultScreen .final-result-container');
          const finalImg = document.getElementById('finalResultImage');
          if (container && finalImg) {
            let wm = container.querySelector('.fitrite-watermark');
            if (!wm) {
              wm = document.createElement('div');
              wm.className = 'fitrite-watermark';
              wm.innerHTML = '<div class="fit-line"></div>FITRITE';
              container.style.position = container.style.position || 'relative';
              container.appendChild(wm);
            }
            // Position watermark within the image bounds
            positionWatermarkForImage(finalImg, container, wm);
            if (!finalImg.complete) {
              finalImg.addEventListener('load', () => positionWatermarkForImage(finalImg, container, wm), { once: true });
            }
            // Keep locked on resizes
            try {
              const handler = () => positionWatermarkForImage(finalImg, container, wm);
              window.addEventListener('resize', handler);
              const ro = new (window.ResizeObserver || function(cb){ window.addEventListener('resize', cb); })((entries)=>handler());
              try { ro.observe(finalImg); } catch(_) {}
            } catch(_) {}
          }
        } catch(_) {}
      }, 1000);
    }

    function showTryOnInterface() {
      const modal = document.getElementById('productModal');
      const modelUploadSection = document.getElementById('modelUploadSection');
      const finalResultScreen = document.getElementById('finalResultScreen');
      
      // Hide final result screen first
      finalResultScreen.classList.remove('show');
      
      setTimeout(() => {
        finalResultScreen.style.display = 'none';
        
        // Always remove any existing floating image and recreate it
        const existingFloatingImage = document.getElementById('floatingProductImage');
        if (existingFloatingImage) {
          existingFloatingImage.remove();
        }
        // Ensure arrows stay hidden while returning from final
        try { document.getElementById('tryOnArrows').classList.remove('show'); } catch(_) {}
        
        // Reset upload state completely
        personFile = null;
        resultImageUrl = null;
        isProcessing = false;
        hasProcessingCompleted = false; // Reset processing completed flag
        hasActivatedAI = false;
        try { localStorage.removeItem(RESULT_STORAGE_KEY); } catch(_) {}
        
        // Reset file input
        const fileInput = document.getElementById('personFileInput');
        if (fileInput) {
          fileInput.value = '';
        }
        
        // Reset and show model upload section explicitly
        modelUploadSection.style.display = 'block';
        modelUploadSection.style.opacity = '1';
        modelUploadSection.classList.remove('show', 'scroll-up');

        // Hard guard: keep arrows hidden while returning to catalogue / reset state
        try { document.getElementById('tryOnArrows').classList.remove('show'); } catch(_) {}
        
        // Reset upload area to initial state
        const personUploadArea = document.getElementById('personUploadArea');
        const uploadContainer = document.querySelector('.upload-container');
        const personPhotoPreview = document.getElementById('personPhotoPreview');
        const removeBtn = document.getElementById('removePhotoBtn');
        const continueBtn = document.getElementById('continueBtn');
        const resultActionsExternal = document.getElementById('resultActionsExternal');
        const resultBackBtn = document.getElementById('resultBackBtn');
        const resultInPlace = document.getElementById('resultInPlace');
        const resultImageInPlace = document.getElementById('resultImageInPlace');
        const uploadPrompt = document.getElementById('uploadPrompt');
        const uploadTitle = document.querySelector('.upload-title');
        const personUploadInner = document.getElementById('personUploadInner');
        
        // Reset all upload elements to initial state
        if (personUploadArea) personUploadArea.classList.remove('has-photo');
        if (uploadContainer) uploadContainer.classList.remove('has-photo');
        if (personPhotoPreview) {
          personPhotoPreview.classList.remove('show', 'fade-out');
          personPhotoPreview.style.display = 'none';
          personPhotoPreview.src = '';
        }
        if (removeBtn) removeBtn.classList.remove('show');
        if (continueBtn) {
          continueBtn.classList.remove('show');
          continueBtn.disabled = true;
        }
        // Hide any residual result UI and clear result image
        if (resultActionsExternal) {
          resultActionsExternal.classList.remove('show');
          resultActionsExternal.style.display = 'none';
        }
        if (resultBackBtn) {
          resultBackBtn.classList.remove('show');
          resultBackBtn.style.display = 'none';
        }
        if (resultInPlace) {
          resultInPlace.classList.remove('show');
          resultInPlace.style.display = 'none';
        }
        if (resultImageInPlace) {
          resultImageInPlace.src = '';
        }
        if (personPhotoPreview) {
          personPhotoPreview.classList.remove('fade-out');
        }
        if (uploadPrompt) {
          uploadPrompt.classList.remove('hidden');
          uploadPrompt.style.opacity = '1';
          uploadPrompt.style.display = 'block';
        }
        if (uploadTitle) {
          uploadTitle.style.opacity = '1';
          uploadTitle.style.display = 'block';
        }
        if (personUploadInner) {
          personUploadInner.style.opacity = '1';
        }
        
        // Always fade out modal elements (same as original Try On)
        const fadeOutElements = document.querySelectorAll('.fade-out-element');
        fadeOutElements.forEach(element => {
          element.classList.add('hidden');
        });
        
        // Show modal first
        modal.style.display = 'flex';
        modal.style.opacity = '1';
        modal.classList.add('show');
        
        // After fade out delay, start container animations (same timing as original)
        setTimeout(() => {
          const modalContent = document.querySelector('.modal-content');
          const productImage = document.getElementById('modalProductImage');
          
          if (window.innerWidth <= 768) {
            // Mobile: Swipe up animation (same as original)
            modalContent.classList.add('try-on-swipe-up');
          } else {
            // Desktop: Extract image first, then fade out container (same as original)
            if (productImage) {
              // Get current position and size of image
              const imageRect = productImage.getBoundingClientRect();
              const modalRect = modal.getBoundingClientRect();
              
              // Clone the image and position it absolutely (same as original)
              const imageClone = productImage.cloneNode(true);
              imageClone.id = 'floatingProductImage';
              imageClone.style.position = 'fixed';
              imageClone.style.left = imageRect.left + 'px';
              imageClone.style.top = imageRect.top + 'px';
              imageClone.style.width = imageRect.width + 'px';
              imageClone.style.height = imageRect.height + 'px';
              imageClone.style.zIndex = '1003';
              imageClone.style.transition = 'all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
              imageClone.style.borderRadius = '15px';
              imageClone.style.boxShadow = '0 8px 32px rgba(0, 0, 0, 0.15)';
              imageClone.style.objectFit = 'contain';
              imageClone.style.display = 'block';
              imageClone.style.opacity = '1';
              
              // Add clone to body
              document.body.appendChild(imageClone);
              
              // Hide original image
              productImage.style.opacity = '0';
              
              // Animate clone to left position after a short delay (same as original)
              setTimeout(() => {
                const leftX = modalRect.left + modalRect.width * 0.25; // Adjust for horizontal alignment
                const centerY = modalRect.top + modalRect.height / 2; // Same vertical center as upload container
                
                imageClone.style.left = leftX + 'px';
                imageClone.style.top = centerY + 'px';
                imageClone.style.width = '300px';
                imageClone.style.height = 'auto'; // Let height adjust naturally
                imageClone.style.transform = 'translate(0, -50%)'; // Center vertically
              }, 100);
            }
            
            // Container fade out (same as original)
            modalContent.classList.add('try-on-container-fadeout');
          }
          
        // Show model upload section after container animation (same timing as original)
        setTimeout(() => {
          showModelUpload();
      try { fetch('https://api.fashn.ai/v1/', { mode: 'no-cors', keepalive: true }); } catch (e) {}
          // GARANTIR que o botão Execute AI apareça se há foto
          ensureExecuteAIButtonVisible();
        }, 600);
      }, 700); // Same delay as original Try On button
    }, 500);
  }

    function hideFinalResultScreen() {
      const finalResultScreen = document.getElementById('finalResultScreen');
      finalResultScreen.style.transition = 'opacity 1.5s ease-out, transform 1.5s ease-out';
      finalResultScreen.classList.remove('show');
      try { document.getElementById('tryOnArrows').classList.remove('show'); } catch(_) {}
      
      // Add slide down effect
      const container = finalResultScreen.querySelector('.final-result-container');
      if (container) {
        container.style.transition = 'transform 1.5s ease-out';
        container.style.transform = 'translateY(50px)';
      }
      
      setTimeout(() => {
        finalResultScreen.style.display = 'none';
        // Reset container transform for next time
        if (container) {
          container.style.transform = 'translateY(0)';
        }
        try { document.getElementById('tryOnArrows').classList.remove('show'); } catch(_) {}
      }, 1500);
    }

    function returnToCatalogue() {
      window.tryOnActive = false;
        // Immediately hide arrows first
      try { document.getElementById('tryOnArrows').classList.remove('show'); } catch(_) {}
      // Start smooth fade out of final result screen
      const finalResultScreen = document.getElementById('finalResultScreen');
      finalResultScreen.style.transition = 'opacity 1.5s ease-out';
      finalResultScreen.classList.remove('show');
      
      // After fade out completes, reset everything
      setTimeout(() => {
        finalResultScreen.style.display = 'none';
        
        // Add smooth fade in effect to main content
        document.body.style.transition = 'opacity 0.8s ease-in';
        document.body.style.opacity = '0.3';
        
        // Gradually reset all try-on related elements
        setTimeout(() => {
          hideModelUpload();
          hideResultInPlace();
          
          // Clear the uploaded photo
          if (personFile) {
            removePersonPhoto();
          }
          
          // Reset modal state smoothly
          const modal = document.getElementById('productModal');
          modal.style.transition = 'opacity 0.8s ease-out';
          modal.style.opacity = '1';
          
          setTimeout(() => {
            closeModal();
            
            // Clear current product data and reset all state variables
            currentProductData = null;
            personFile = null;
            resultImageUrl = null;
            isProcessing = false;
            hasProcessingCompleted = false;
            hasActivatedAI = false;
            try { localStorage.removeItem(RESULT_STORAGE_KEY); } catch(_) {}
            
            // Reset file input
            const fileInput = document.getElementById('personFileInput');
            if (fileInput) {
              fileInput.value = '';
            }
            
            // Reset upload interface elements to initial state
            const personUploadArea = document.getElementById('personUploadArea');
            const uploadContainer = document.querySelector('.upload-container');
            const personPhotoPreview = document.getElementById('personPhotoPreview');
            const removeBtn = document.getElementById('removePhotoBtn');
            const continueBtn = document.getElementById('continueBtn');
            const uploadPrompt = document.getElementById('uploadPrompt');
            const uploadTitle = document.querySelector('.upload-title');
            const personUploadInner = document.getElementById('personUploadInner');
            
            if (personUploadArea) personUploadArea.classList.remove('has-photo');
            if (uploadContainer) uploadContainer.classList.remove('has-photo');
            if (personPhotoPreview) {
              personPhotoPreview.classList.remove('show', 'fade-out', 'processing', 'processing-complete');
              personPhotoPreview.style.display = 'none';
              personPhotoPreview.src = '';
            }
            if (removeBtn) removeBtn.classList.remove('show');
            if (continueBtn) {
              continueBtn.classList.remove('show');
              continueBtn.style.display = 'none';
              continueBtn.disabled = true;
            }
            if (uploadPrompt) {
              uploadPrompt.classList.remove('hidden');
              uploadPrompt.style.opacity = '1';
              uploadPrompt.style.display = 'block';
            }
            if (uploadTitle) {
              uploadTitle.style.opacity = '1';
              uploadTitle.style.display = 'block';
            }
            if (personUploadInner) {
              personUploadInner.classList.remove('hidden');
              personUploadInner.style.opacity = '1';
            }
            
            // Reset any floating images
            const floatingImage = document.getElementById('floatingProductImage');
            if (floatingImage) {
              floatingImage.remove();
            }
            
            // Reset modal content animations
            const modalContent = document.querySelector('.modal-content');
            if (modalContent) {
              modalContent.classList.remove('try-on-swipe-up', 'try-on-container-fadeout');
            }
            
            // Reset fade out elements
            const fadeOutElements = document.querySelectorAll('.fade-out-element');
            fadeOutElements.forEach(element => {
              element.classList.remove('hidden');
            });
            
            // Reset original image opacity
            const originalImage = document.getElementById('modalProductImage');
            if (originalImage) {
              originalImage.style.opacity = '1';
            }
            
            // Hide try-on arrows
            document.getElementById('tryOnArrows').classList.remove('show');
            
            // Smooth fade back to full opacity
            setTimeout(() => {
              document.body.style.opacity = '1';
              setTimeout(() => {
                // Remove transition after animation completes
                document.body.style.transition = '';
              }, 800);
            }, 100);
            
          }, 300);
        }, 200);
      }, 1500);
    }

    function buyProduct() {
      if (!currentProductData) {
        showToast('No product selected');
        return;
      }
      
      const selectedSize = document.getElementById('sizeSelector').value;
      
      // Prefer Firebase cart when available; fallback to localStorage addToBasket
      try {
        if (window.FitRightFirebase && typeof window.FitRightFirebase.addProductToCart === 'function') {
          // Build product data similar to extractProductFromModal
          const name = currentProductData.name;
          const priceText = (currentProductData.price || '').toString();
          const numericPrice = parseFloat(priceText.replace(/[£,]/g, ''));
          const priceInCents = Number.isFinite(numericPrice) ? Math.round(numericPrice * 100) : 0;
          const productData = {
            id: `leather_jacket_${name.replace(/[^a-zA-Z0-9]/g, '_')}_${selectedSize.replace(/[^a-zA-Z0-9]/g, '_')}`,
            name: name,
            price: priceInCents,
            image: currentProductData.imgUrl,
            category: 'leather_jackets',
            selectedSize: selectedSize
          };
          // Try to merge quantities if item exists
          const items = (typeof window.FitRightFirebase.getCartItems === 'function') ? window.FitRightFirebase.getCartItems() : [];
          const existing = items.find(it => it.name === productData.name && (it.selectedSize || it.size) === productData.selectedSize);
          if (existing && typeof window.FitRightFirebase.updateQuantity === 'function') {
            window.FitRightFirebase.updateQuantity(existing.id || existing.productId, (existing.quantity || 1) + 1);
          } else {
            window.FitRightFirebase.addProductToCart(productData, 1);
          }
          showToast('Product added to basket!');
          try { window.dispatchEvent(new CustomEvent('cartUpdated')); } catch(_) {}
          if (typeof updateBasketDropdown === 'function') updateBasketDropdown();
          returnToCatalogue();
          return;
        }
      } catch (_) {
        // Ignore and fallback
      }
      
      // Fallback: local storage
      addToBasket(
        currentProductData.name,
        currentProductData.price,
        currentProductData.imgUrl,
        selectedSize,
        true
      );
      if (typeof updateBasketDropdown === 'function') updateBasketDropdown();
      returnToCatalogue();
    }

    function hideResultInPlace() {
      const resultInPlace = document.getElementById('resultInPlace');
      const resultImg = document.getElementById('resultImageInPlace');
      const resultBackBtn = document.getElementById('resultBackBtn');
      const resultActionsExternal = document.getElementById('resultActionsExternal');
      const personPhotoPreview = document.getElementById('personPhotoPreview');

      if (resultInPlace) {
        resultInPlace.classList.remove('show');
        resultInPlace.style.display = 'none';
      }
      if (resultBackBtn) {
        resultBackBtn.classList.remove('show');
        resultBackBtn.style.display = 'none';
      }
      if (resultActionsExternal) {
        resultActionsExternal.classList.remove('show');
        resultActionsExternal.style.display = 'none';
      }
      if (resultImg) {
        resultImg.src = '';
      }
      if (personPhotoPreview) {
        personPhotoPreview.classList.remove('fade-out');
      }
      
      // GARANTIR que o botão Execute AI apareça se há foto
      ensureExecuteAIButtonVisible();
      
      // Reset to show person photo again
      setTimeout(() => {
        if (personFile && personPhotoPreview) {
          personPhotoPreview.classList.add('show');
        }
      }, 100);
    }

    function toggleResultView() {
      const resultInPlace = document.getElementById('resultInPlace');
      const personPhotoPreview = document.getElementById('personPhotoPreview');
      const resultBackBtn = document.getElementById('resultBackBtn');
      const resultActionsExternal = document.getElementById('resultActionsExternal');
      const isShowingResult = resultInPlace.classList.contains('show');
      
      if (isShowingResult) {
        // Back to original photo: hide result overlay and external actions
        resultInPlace.classList.remove('show');
        if (resultActionsExternal) {
          resultActionsExternal.classList.remove('show');
          resultActionsExternal.style.display = 'none';
        }
        personPhotoPreview.classList.remove('fade-out');
        personPhotoPreview.classList.add('show');
        resultBackBtn.title = "Try on item again";
        resultBackBtn.textContent = "→";
      } else {
        // Show result again: show external actions
        personPhotoPreview.classList.add('fade-out');
        resultInPlace.classList.add('show');
        if (resultActionsExternal) {
          resultActionsExternal.style.display = 'block';
          resultActionsExternal.classList.add('show');
        }
        resultBackBtn.title = "Remove item";
        resultBackBtn.textContent = "←";
      }
    }

    function downloadResult() {
      // Always use the exact image currently shown on screen
      let currentUrl = '';
      try {
        const finalEl = document.getElementById('finalResultImage');
        const inPlaceEl = document.getElementById('resultImageInPlace');
        currentUrl = (finalEl && finalEl.src) || (inPlaceEl && inPlaceEl.src) || window.resultImageUrl || '';
        if (currentUrl) { window.resultImageUrl = currentUrl; resultImageUrl = currentUrl; }
      } catch(_) {}

      if (!currentUrl) {
        console.error('❌ Nenhuma imagem resultado disponível para download');
        alert('Nenhuma imagem disponível para download. Faça um try-on primeiro!');
        return;
      }

      // Try to compose the watermark into the image before downloading
      (async () => {
        try {
          const blob = await fetch(currentUrl).then(r => {
            if (!r.ok) throw new Error('Failed to fetch image');
            return r.blob();
          });
          const imgUrl = URL.createObjectURL(blob);
          const img = new Image();
          img.decoding = 'sync';
          img.src = imgUrl;
          await (img.decode ? img.decode().catch(()=>{}) : new Promise(res => img.onload = res));

          // Determine which view is active to read watermark sizing/offsets
          const finalScreen = document.getElementById('finalResultScreen');
          const useFinal = finalScreen && finalScreen.classList.contains('show');
          const container = useFinal
            ? document.querySelector('#finalResultScreen .final-result-container')
            : document.getElementById('resultInPlace');
          const imgEl = useFinal ? document.getElementById('finalResultImage') : document.getElementById('resultImageInPlace');
          const wmEl = container ? container.querySelector('.fitrite-watermark') : null;
          const lineEl = wmEl ? wmEl.querySelector('.fit-line') : null;

          // Canvas at full image resolution
          const cnv = document.createElement('canvas');
          cnv.width = img.naturalWidth || img.width;
          cnv.height = img.naturalHeight || img.height;
          const ctx = cnv.getContext('2d');
          ctx.drawImage(img, 0, 0, cnv.width, cnv.height);

          // If we have watermark on screen, match its size/offsets EXACTLY as rendered
          if (wmEl && imgEl) {
            const imgRect = imgEl.getBoundingClientRect();
            const wmRect = wmEl.getBoundingClientRect();
            const scaleX = (cnv.width) / Math.max(1, imgRect.width);
            const scaleY = (cnv.height) / Math.max(1, imgRect.height);

            const marginRightPx = Math.max(0, imgRect.right - wmRect.right);
            const marginBottomPx = Math.max(0, imgRect.bottom - wmRect.bottom);

            const cs = getComputedStyle(wmEl);
            const fontSize = parseFloat(cs.fontSize) || 16;
            const fontWeight = cs.fontWeight || '400';
            const fontFamily = cs.fontFamily || 'Georgia, "Times New Roman", Times, serif';
            // Use only the text node for the label (exclude the line div)
            const textNode = Array.from(wmEl.childNodes).find(n => n.nodeType === Node.TEXT_NODE);
            const text = (textNode ? textNode.textContent : (wmEl.textContent || 'FITRITE')).replace(/\s+/g, ' ').trim();

            // Configure canvas text using exact container box for pixel-identical placement
            ctx.fillStyle = '#ffffff';
            ctx.textBaseline = 'bottom';
            ctx.textAlign = 'right';
            ctx.font = `${fontWeight} ${Math.max(1, fontSize * scaleY)}px ${fontFamily}`;

            const xRight = (wmRect.right - imgRect.left) * scaleX;
            const yBottom = (wmRect.bottom - imgRect.top) * scaleY;

            // Optional line above text (map DOM rect -> canvas 1:1)
            if (lineEl) {
              const lineRect = lineEl.getBoundingClientRect();
              const dLW = Math.max(1, lineRect.width * scaleX);
              const dLH = Math.max(1, lineRect.height * scaleY);
              const leftOffsetLine = Math.max(0, lineRect.left - imgRect.left);
              const topOffsetLine = Math.max(0, lineRect.top - imgRect.top);
              const xL = leftOffsetLine * scaleX;
              const yT = topOffsetLine * scaleY;
              ctx.fillStyle = '#ffffff';
              ctx.fillRect(xL, yT, dLW, dLH);
            }

            // Draw text last
            ctx.fillStyle = '#ffffff';
            ctx.fillText(text, xRight, yBottom);
          }

          // Export and download
          cnv.toBlob((outBlob) => {
            try { URL.revokeObjectURL(imgUrl); } catch(_) {}
            if (!outBlob) return;
            const dlUrl = URL.createObjectURL(outBlob);
            const link = document.createElement('a');
            link.href = dlUrl;
            link.download = `fitrite-virtual-tryon-${Date.now()}.jpg`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            setTimeout(() => { try { URL.revokeObjectURL(dlUrl); } catch(_) {} }, 1000);
          }, 'image/jpeg', 0.95);
        } catch (err) {
          console.error('Watermarked export failed, falling back to raw download', err);
          // Fallback to raw image download
            const link = document.createElement('a');
          link.href = currentUrl;
            link.download = `fitrite-virtual-tryon-${Date.now()}.jpg`;
            link.target = '_blank';
            link.style.display = 'none';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
      }
      })();
    }
    
    function shareResult() {
      if (resultImageUrl && navigator.share) {
        // Use Web Share API if available
        fetch(resultImageUrl)
          .then(response => response.blob())
          .then(blob => {
            const file = new File([blob], `fitrite-virtual-tryon-${Date.now()}.jpg`, { type: 'image/jpeg' });
            navigator.share({
              title: 'My Virtual Try-On at Fitrite',
              text: 'Look at my virtual try-on at Fitrite 🔥',
              files: [file]
            });
          })
          .catch(err => {
            console.error('Error sharing:', err);
            // Fallback to copying link
            copyToClipboard();
          });
      } else {
        // Fallback for browsers without Web Share API
        copyToClipboard();
      }
    }
    
    function copyToClipboard() {
      if (resultImageUrl) {
        // Create a temporary canvas to convert the image to data URL
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const img = new Image();
        img.onload = function() {
          canvas.width = img.width;
          canvas.height = img.height;
          ctx.drawImage(img, 0, 0);
          canvas.toBlob(blob => {
            navigator.clipboard.write([
              new ClipboardItem({ 'image/png': blob })
            ]).then(() => {
              showToast('Image copied to clipboard!');
            }).catch(() => {
              showToast('Share feature not supported on this device');
            });
          });
        };
        img.src = resultImageUrl;
      }
    }
    
    function showToast(message) {
      const toastEl = document.getElementById("toast");
      toastEl.textContent = message;
      toastEl.classList.add("show");
      setTimeout(() => {
        toastEl.classList.remove("show");
      }, 2000);
    }
    
    // Define all leather jacket products
    const leatherJackets = [
      
        {
          "id": "img_jacket_6",
          "name": "Rugged Grey Field Jacket",
          "category": "leather jackets",
          "imagePath": "rugged_green_field_jacket.jpg",
          "price": 140,
          "discount": false,
          "discountPercent": 12
        },
        {
          "id": "img_jacket_3",
          "name": "Vintage Brown Bomber",
          "category": "leather jackets",
          "imagePath": "vintage_brown_bomber.jpg",
          "price": 185,
          "discount": true,
          "discountPercent": 40
        },
        {
          "id": "img_jacket_5",
          "name": "Modern Blue Moto",
          "category": "leather jackets",
          "imagePath": "modern_blue_moto.jpg",
          "price": 225,
          "discount": true,
          "discountPercent": 70
        },
        {
          "id": "img_jacket_2",
          "name": "Sleek Blue Racer",
          "category": "leather jackets",
          "imagePath": "sleek_red_racer.jpg",
          "price": 170,
          "discount": true,
          "discountPercent": 60
        },
        {
          "id": "img_jacket_7",
          "name": "Silver Streak Jacket",
          "category": "leather jackets",
          "imagePath": "silver_streak_jacket.jpg",
          "price": 165,
          "discount": false,
          "discountPercent": 0
        },
        {
          "id": "img_jacket_8",
          "name": "Metallic Finish Racer",
          "category": "leather jackets",
          "imagePath": "metallic_finish_racer.jpg",
          "price": 175,
          "discount": false,
          "discountPercent": 0
        }
    ];

    // Function to render all leather jackets with discounts
    function renderLeatherJackets(jackets) {
      console.log("renderLeatherJackets called with:", jackets);
      const productsContainer = document.getElementById("products-container");
      console.log("productsContainer element:", productsContainer);
      productsContainer.innerHTML = ''; // Clear container
      
      jackets.forEach(jacket => {
        // Create product div
        const productDiv = document.createElement("div");
        productDiv.className = "product";
        
        let priceHtml = '';
        let discountTag = '';
        
        if (jacket.discount) {
          // Calculate discounted price
          const discountedPrice = Math.round(jacket.price * (1 - jacket.discountPercent / 100));
          
          // Create price HTML with original and new price
          priceHtml = `
            <p class="product-price">
              <span class="original-price">£${jacket.price}</span>
              <span class="new-price">£${discountedPrice}</span>
            </p>
          `;
          
          // Create discount tag based on discount percentage
          if (jacket.discountPercent > 55) {
            // Gold Tag (> 55%)
            discountTag = `
              <div class="discount-tag gold">★★ ${jacket.discountPercent}% OFF – Bargain of the Day ★★</div>
            `;
          } else {
            // Red Tag (≤ 55%)
            discountTag = `
              <div class="discount-tag red">★ ${jacket.discountPercent}% OFF ★</div>
            `;
          }
          
          // Set click handler with discount info
          productDiv.addEventListener("click", () => {
            openModal(jacket.name, `£${discountedPrice}`, jacket.imagePath, true, `£${jacket.price}`);
          });
        } else {
          // Regular price for non-discounted items
          priceHtml = `<p class="product-price">£${jacket.price}</p>`;
          
          // Set click handler without discount info
          productDiv.addEventListener("click", () => {
            openModal(jacket.name, `£${jacket.price}`, jacket.imagePath);
          });
        }
        
        // Build the product HTML
        productDiv.innerHTML = `
          ${discountTag}
          <div class="image-container">
            <img src="${jacket.imagePath}" alt="${jacket.name}" width="4" height="5" onerror="this.style.visibility='hidden';">
          </div>
          <p class="product-name">${jacket.name}</p>
          ${priceHtml}
        `;
        
        productsContainer.appendChild(productDiv);
      });
    }
    
    // Load products and apply discounts from JSON
    async function loadProducts() {
      console.log("loadProducts called");
      console.log("leatherJackets array:", leatherJackets);
      try {
        // Try to fetch the products.json file
        const response = await fetch('./products.json');
        let discountedProducts = [];
        
        if (response.ok) {
          // If products.json is available, use it
          discountedProducts = await response.json();
          console.log("Loaded discounted products from JSON:", discountedProducts);
          
          // Extract just the leather jacket discounts
          const jacketDiscounts = discountedProducts
            .filter(product => product.category === "leather jackets")
            .map(product => ({
              id: product.id,
              discountPercent: product.discountPercent
            }));
          
          // Render leather jackets with discounts from JSON
          renderLeatherJackets(leatherJackets);
        } else {
          // If products.json is not available, use the built-in discounts
          console.warn("Could not load products.json, using built-in discount data");
          renderLeatherJackets(leatherJackets);
        }
      } catch (error) {
        // If there's an error, use the built-in discounts
        console.error("Error loading products:", error);
        renderLeatherJackets(leatherJackets);
      }
    }
    
    // Função para resetar estados da interface Try-On
    function resetTryOnStates() {
      const modelUploadSection = document.getElementById('modelUploadSection');
      const modalContent = document.querySelector('.modal-content');
      const tryOnArrows = document.getElementById('tryOnArrows');
      const floatingImage = document.getElementById('floatingProductImage');
      
      // Remove classes de animação
      if (modalContent) {
        modalContent.classList.remove('try-on-swipe-up', 'try-on-container-fadeout');
        // Remove qualquer estilo de animação inline
        modalContent.style.animation = '';
        modalContent.style.transform = '';
      }
      
      // Remove classes de estado
      if (modelUploadSection) {
        modelUploadSection.classList.remove('show', 'scroll-up');
        // Remove estilos inline de animação
        modelUploadSection.style.animation = '';
        modelUploadSection.style.transition = '';
        
        // Redefine posicionamento baseado no viewport atual
        if (window.innerWidth <= 768) {
          modelUploadSection.style.position = 'fixed';
          modelUploadSection.style.top = '50%';
          modelUploadSection.style.left = '50%';
          modelUploadSection.style.transform = 'translate(-50%, -50%)';
          modelUploadSection.style.width = '90vw';
          modelUploadSection.style.maxWidth = '400px';
        } else {
          modelUploadSection.style.position = 'fixed';
          modelUploadSection.style.left = '65%';
          modelUploadSection.style.top = '50%';
          modelUploadSection.style.transform = 'translate(0, -50%)';
          modelUploadSection.style.width = '300px';
          modelUploadSection.style.maxWidth = '35vw';
        }
      }
      
      // Remove setas
      if (tryOnArrows) {
        tryOnArrows.classList.remove('show');
        tryOnArrows.style.animation = '';
      }
      
      // Manter imagem flutuante para reaproveitar no desktop; apenas garantir transição suave
      if (floatingImage) {
  floatingImage.style.transition = 'all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
  floatingImage.style.opacity = floatingImage.style.opacity || '1';
      }
      // Reset variáveis de estado
      if (typeof isProcessing !== 'undefined') {
        isProcessing = false;
      }
    }

    // Event listener para mudanças de viewport com debounce
    let resizeTimeout;
    function handleViewportChangeV1() {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        try { console.log('🔄 Mudança de viewport detectada:', window.innerWidth + 'px'); } catch(_) {}
        const modal = document.getElementById('productModal');
        const modelUploadSection = document.getElementById('modelUploadSection');
        const floatingImg = document.getElementById('floatingProductImage');
        // Consider try-on active if modal is open and either we flagged tryOnActive,
        // the upload section is showing or the floating image exists (desktop in-progress)
        // Try-on mode only if user explicitly activated it
        const isInTryOnMode = !!(modal && modal.classList.contains('show') && window.tryOnActive);
        if (isInTryOnMode) {
          // Immediately hide the modal content to prevent white-box flash during resize
          try {
            const mc = document.querySelector('.modal-content');
            if (mc) {
              mc.style.transition = 'opacity 120ms ease';
              mc.style.opacity = '0';
              mc.style.pointerEvents = 'none';
            }
          } catch(_) {}
          if (typeof resetTryOnStates === 'function') resetTryOnStates();
          setTimeout(() => {
            try { applyTryOnLayout(); } catch(_) {}
            // enforce final state shortly after transitions
            setTimeout(() => { try { ensureTryOnConsistency(); } catch(_) {} }, 140);
          }, 100);
        } else {
          if (typeof resetTryOnStates === 'function') resetTryOnStates();
        }
      }, 250);
    }
    // Removed old handleViewportChange implementation to avoid conflicts

    // Nova função para aplicar layout try-on baseado no viewport

// Ensure final state exactly matches the current viewport (idempotent)
function ensureTryOnConsistency() {
  if (!window.tryOnActive) {
    return;
  }
  const isMobile = window.innerWidth <= 768;
      const modal = document.getElementById('productModal');
      const modalContent = document.querySelector('.modal-content');
  const modelUploadSection = document.getElementById('modelUploadSection');
      const productImage = document.getElementById('modalProductImage');
      const tryOnArrows = document.getElementById('tryOnArrows');
  let floating = document.getElementById('floatingProductImage');

  if (!modal || !modal.classList.contains('show')) {
    const stray = document.getElementById('floatingProductImage');
    if (stray) { try { stray.remove(); } catch(_) {} }
    return;
  }

  if (isMobile) {
    if (floating) { try { floating.remove(); } catch(_) {} }
    if (tryOnArrows) tryOnArrows.classList.remove('show');
      if (modalContent) {
      modalContent.classList.remove('try-on-container-fadeout');
      modalContent.style.opacity = '';
      modalContent.style.pointerEvents = '';
      if (!modalContent.classList.contains('try-on-swipe-up')) {
        modalContent.classList.add('try-on-swipe-up');
      }
    }
    if (modelUploadSection) {
      modelUploadSection.classList.add('show', 'scroll-up');
      modelUploadSection.style.opacity = '1';
    }
  } else {
    // Show arrows only after user explicitly clicks Try On
    if (window.tryOnActive && tryOnArrows) tryOnArrows.classList.add('show');
    if (!floating && productImage) {
      const rect = productImage.getBoundingClientRect();
      floating = productImage.cloneNode(true);
      floating.id = 'floatingProductImage';
      floating.style.position = 'fixed';
      floating.style.left = rect.left + 'px';
      floating.style.top = rect.top + 'px';
      floating.style.width = rect.width + 'px';
      floating.style.height = rect.height + 'px';
      floating.style.zIndex = '1003';
      floating.style.transition = 'all 280ms cubic-bezier(0.25, 0.46, 0.45, 0.94)';
      floating.style.borderRadius = '15px';
      floating.style.boxShadow = '0 8px 32px rgba(0,0,0,0.15)';
      floating.style.objectFit = 'contain';
      document.body.appendChild(floating);
      const modalRect = modal.getBoundingClientRect();
      const targetLeft = modalRect.left + modalRect.width * 0.25;
      const targetTop = modalRect.top + modalRect.height / 2;
      requestAnimationFrame(() => {
        floating.style.left = targetLeft + 'px';
        floating.style.top = targetTop + 'px';
        floating.style.width = '300px';
        floating.style.height = 'auto';
        floating.style.transform = 'translate(0, -50%)';
        floating.style.opacity = '1';
      });
    }
            if (modalContent) {
      modalContent.classList.add('try-on-container-fadeout');
      modalContent.style.opacity = '0';
      modalContent.style.pointerEvents = 'none';
      modalContent.classList.remove('try-on-swipe-up');
    }
    if (modelUploadSection) {
      modelUploadSection.classList.add('show');
      modelUploadSection.classList.remove('scroll-up');
            modelUploadSection.style.opacity = '1';
    }
  }
}

// Load products when the page loads
    document.addEventListener('DOMContentLoaded', function() {
      loadProducts();
      
      // Adiciona event listener para mudanças de viewport
      

function applyTryOnLayout() {
  const modelUploadSection = document.getElementById('modelUploadSection');
  const modal = document.getElementById('productModal');
  const modalContent = document.querySelector('.modal-content');
  const productImage = document.getElementById('modalProductImage');
  const tryOnArrows = document.getElementById('tryOnArrows');
  const resultInPlace = document.getElementById('resultInPlace');
  const resultImg = document.getElementById('resultImageInPlace');
  const resultBackBtn = document.getElementById('resultBackBtn');
  const resultActionsExternal = document.getElementById('resultActionsExternal');

  if (!modelUploadSection || !modal || !modalContent) return;

  const isMobile = window.innerWidth <= 768;
  // Clear transient classes/styles
  modalContent.classList.remove('try-on-swipe-up', 'try-on-container-fadeout');
  modelUploadSection.classList.remove('scroll-up');
  modelUploadSection.style.opacity = '';

  // If we're in the upload-your-photo state (no result showing), ensure residual result UI is hidden
  const isResultVisible = resultInPlace && resultInPlace.classList.contains('show');
  if (!isResultVisible) {
    if (resultInPlace) { resultInPlace.classList.remove('show'); resultInPlace.style.display = 'none'; }
    if (resultBackBtn) { resultBackBtn.classList.remove('show'); resultBackBtn.style.display = 'none'; }
    if (resultActionsExternal) { resultActionsExternal.classList.remove('show'); resultActionsExternal.style.display = 'none'; }
    if (resultImg) { resultImg.src = ''; }
    // Also remove any final screen if visible
    const finalScreen = document.getElementById('finalResultScreen');
    if (finalScreen) { finalScreen.classList.remove('show'); finalScreen.style.display = 'none'; }
    // Force overlay elements hidden
    const processingOverlay = document.getElementById('processingOverlayLocal');
    if (processingOverlay) processingOverlay.classList.remove('show');
  }

  if (isMobile) {
    // Desktop → Mobile
    if (tryOnArrows) tryOnArrows.classList.remove('show');
    // Remove floating image entirely on mobile to avoid ghost on the right
    const floating = document.getElementById('floatingProductImage');
    if (floating) { try { floating.remove(); } catch(_) {} }
    // Ensure modal content visible on mobile and apply swipe-up
    modalContent.style.opacity = '';
    modalContent.style.pointerEvents = '';
    modalContent.classList.add('try-on-swipe-up');
    if (productImage) { productImage.style.opacity = '1'; }
    requestAnimationFrame(() => {
      modelUploadSection.classList.add('show', 'scroll-up');
      modelUploadSection.style.opacity = '1';
    });
  } else {
    // Mobile → Desktop
    // Show arrows only after user explicitly clicks Try On
    if (window.tryOnActive && tryOnArrows) tryOnArrows.classList.add('show');
    let floating = document.getElementById('floatingProductImage');
    if (!floating && productImage) {
      const rect = productImage.getBoundingClientRect();
      floating = productImage.cloneNode(true);
      floating.id = 'floatingProductImage';
      floating.style.position = 'fixed';
      floating.style.left = rect.left + 'px';
      floating.style.top = rect.top + 'px';
      floating.style.width = rect.width + 'px';
      floating.style.height = rect.height + 'px';
      floating.style.zIndex = '1003';
      floating.style.transition = 'all 320ms cubic-bezier(0.25, 0.46, 0.45, 0.94)';
      floating.style.borderRadius = '15px';
      floating.style.boxShadow = '0 8px 32px rgba(0,0,0,0.15)';
      floating.style.objectFit = 'contain';
      document.body.appendChild(floating);
      // Dim original image inside modal to avoid double-vision
      productImage.style.opacity = '0';
    } else if (floating) {
      floating.style.display = 'block';
      floating.style.opacity = '1';
    }
    // Animate floating image to its desktop target
    const modalRect = modal.getBoundingClientRect();
    const targetLeft = modalRect.left + modalRect.width * 0.25;
    const targetTop = modalRect.top + modalRect.height / 2;
    if (floating) {
      floating.style.transition = 'all 280ms cubic-bezier(0.25, 0.46, 0.45, 0.94)';
      floating.style.left = targetLeft + 'px';
      floating.style.top = targetTop + 'px';
      floating.style.width = '300px';
      floating.style.height = 'auto';
      floating.style.transform = 'translate(0, -50%)';
      floating.style.opacity = '1';
    }
    // Ensure the original modal content transitions on desktop (match v1; do not force display none)
            if (modalContent) {
              modalContent.classList.add('try-on-container-fadeout');
      modalContent.style.opacity = '0';
      modalContent.style.pointerEvents = 'none';
            }
            modelUploadSection.classList.add('show');
            modelUploadSection.style.opacity = '1';
  }

  // Safety: ensure CTA visible if photo exists and not processing
  if (typeof ensureExecuteAIButtonVisible === 'function') {
    setTimeout(() => { if (!window.isProcessing) ensureExecuteAIButtonVisible(); }, 140);
  }
  // Enforce consistent final state
  try { ensureTryOnConsistency(); } catch(_) {}
}

window.addEventListener('resize', handleViewportChangeV1);
      
      // VERIFICAÇÃO PERIÓDICA: Garantir que o botão Execute AI sempre apareça quando há foto (mas não durante processamento)
      setInterval(() => {
        if (personFile && !isProcessing) {
          const continueBtn = document.getElementById('continueBtn');
          if (continueBtn && (!continueBtn.classList.contains('show') || continueBtn.disabled || continueBtn.style.display === 'none')) {
            console.log('🔄 Verificação periódica: Reativando botão Execute AI...');
            ensureExecuteAIButtonVisible();
            try { ensureTryOnConsistency(); } catch(_) {}
          }
        }
      }, 2000); // Verifica a cada 2 segundos
    });
    

    
    // Basket functionality
    const basketCount = document.getElementById("basketCount");
    const basketCountMobile = document.getElementById("basketCountMobile");
    const basketDropdown = document.getElementById("basketDropdown");
    const basketDropdownMobile = document.getElementById("basketDropdownMobile");
    const basketDropdownBtn = document.getElementById("basketDropdownBtn");
    const basketDropdownBtnMobile = document.getElementById("basketDropdownBtnMobile");
    const basketDropdownContent = document.getElementById('basketDropdownContent');
    const basketDropdownContentMobile = document.getElementById('basketDropdownContentMobile');
    
    function toggleBasket(event) {
      event.preventDefault();
      if (basketDropdown) {
        basketDropdown.classList.toggle("show");
      }
    }
    
    function toggleBasketMobile(event) {
      event.preventDefault();
      if (basketDropdownMobile) {
        basketDropdownMobile.classList.toggle("show");
      }
    }
    
    // Basket button click handlers
    basketDropdownBtn.addEventListener('click', function(e) {
      console.log('Basket button clicked!');
      e.stopPropagation();
      updateBasketDropdown();
      if (basketDropdown.classList.contains('show')) {
        console.log('Closing basket dropdown');
        basketDropdown.classList.remove('show');
        setTimeout(() => { basketDropdown.style.display = 'none'; }, 300);
      } else {
        console.log('Opening basket dropdown');
        basketDropdown.style.display = 'block';
        setTimeout(() => { basketDropdown.classList.add('show'); }, 10);
      }
    });
    
    if (basketDropdownBtnMobile && basketDropdownMobile) {
      basketDropdownBtnMobile.addEventListener('click', function(e) {
        console.log('Mobile basket button clicked!');
        e.stopPropagation();
        updateBasketDropdown();
        // Toggle the dedicated mobile dropdown directly below the button
        if (basketDropdownMobile.classList.contains('show')) {
          console.log('Closing mobile basket dropdown');
          basketDropdownMobile.classList.remove('show');
          setTimeout(() => { basketDropdownMobile.style.display = 'none'; }, 300);
        } else {
          console.log('Opening mobile basket dropdown');
          basketDropdownMobile.style.display = 'block';
          setTimeout(() => { basketDropdownMobile.classList.add('show'); }, 10);
        }
      });
    }
    
    document.addEventListener('click', function(e) {
      const clickedInsideDesktop = basketDropdown && basketDropdown.contains(e.target);
      const clickedInsideMobile = basketDropdownMobile && basketDropdownMobile.contains(e.target);
      const clickedButton = e.target === basketDropdownBtn || e.target === basketDropdownBtnMobile || (e.target.closest && (e.target.closest('#basketDropdownBtn') || e.target.closest('#basketDropdownBtnMobile')));
      if (!clickedInsideDesktop && !clickedInsideMobile && !clickedButton) {
        if (basketDropdown && basketDropdown.classList.contains('show')) {
          basketDropdown.classList.remove('show');
          setTimeout(() => { basketDropdown.style.display = 'none'; }, 300);
        }
        if (basketDropdownMobile && basketDropdownMobile.classList.contains('show')) {
          basketDropdownMobile.classList.remove('show');
          setTimeout(() => { basketDropdownMobile.style.display = 'none'; }, 300);
        }
      }
    });
    
    // Basket data storage
    window.basket = JSON.parse(localStorage.getItem("basket")) || [];

    async function updateBasketDropdown() {
      // Get cart data from Firebase or localStorage fallback (match belts.html behavior)
      let cartItems, cartCount;
      if (window.FitRightFirebase && window.FitRightFirebase.isLoggedIn()) {
        cartItems = window.FitRightFirebase.getCartItems();
        cartCount = window.FitRightFirebase.getCartCount();
      } else {
        const basket = JSON.parse(localStorage.getItem("basket")) || [];
        cartItems = basket;
        cartCount = basket.reduce((sum, item) => sum + (item.quantity || 1), 0);
      }
      
      if (cartItems.length === 0) {
        basketDropdownContent.innerHTML = '<div style="text-align:center;color:#888;">Your basket is empty.</div>';
        
        // Update mobile basket content
        const basketDropdownContentMobile = document.getElementById('basketDropdownContentMobile');
        if (basketDropdownContentMobile) {
          basketDropdownContentMobile.innerHTML = '<div style="text-align:center;color:#888;">Your basket is empty.</div>';
        }
        
        basketCount.style.display = 'none';
        if (basketCountMobile) {
          basketCountMobile.textContent = '0';
          basketCountMobile.style.display = 'none';
        }
        
        // Hide clear basket button when empty
        const basketDropdownFooter = document.getElementById('basketDropdownFooter');
        const basketDropdownFooterMobile = document.getElementById('basketDropdownFooterMobile');
        if (basketDropdownFooter) {
          basketDropdownFooter.style.display = 'none';
        }
        if (basketDropdownFooterMobile) {
          basketDropdownFooterMobile.style.display = 'none';
        }
        
        return;
      }
      
      basketCount.textContent = cartCount;
      basketCount.style.display = 'inline-block';
      if (basketCountMobile) {
        basketCountMobile.textContent = cartCount;
        basketCountMobile.style.display = (cartCount === 0) ? 'none' : 'inline-block';
      }
      
      // Create basket HTML for both desktop and mobile
      const basketHTML = cartItems.map((item, idx) => {
        // Debug: Log each basket item
        console.log('Basket item:', item);
        
        return `
        <div class="basket-row" data-index="${idx}" data-id="${item.id || item.productId || idx}" style="display:flex;align-items:center;margin-bottom:12px;padding-bottom:8px;position:relative;">
          <div style="width:48px;height:48px;background:#fafafa;border-radius:10px;margin-right:12px;display:flex;align-items:center;justify-content:center;">
            <img src="${item.imgUrl || item.image || item.productImage}" alt="${item.name || item.productName}" style="width:100%;height:100%;object-fit:contain;border-radius:10px;" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex'; console.log('Image failed to load:', this.src);">
            <div style="display:none;width:100%;height:100%;align-items:center;justify-content:center;color:#999;font-size:12px;text-align:center;line-height:1.2;">📦</div>
          </div>
          <div style="flex:1;">
            <div style="font-family:'Special Elite',monospace;font-size:1em;">${item.name || item.productName}</div>
            <div style="font-size:1em;font-weight:bold;">${(window.FitRightFirebase && window.FitRightFirebase.formatPrice && (item.productPrice != null || typeof item.price === 'number')) ? window.FitRightFirebase.formatPrice((item.productPrice ?? item.price)) : (item.newPrice || '£0.00')}</div>
            <div style="font-size:0.95em;color:#555;">Qty: <span class="basket-qty" data-id="${item.id || item.productId || idx}">${item.quantity || 1}</span></div>
            ${(() => { const _s = ((item.selectedSize || item.size) || '').toString().trim(); return _s && !/^standard$/i.test(_s) ? `<div style="font-size:0.95em;color:#555;">Size: ${_s}</div>` : '' })()}
          </div>
          <button class="basket-minus-btn" data-index="${idx}" data-id="${item.id || item.productId || idx}">&minus;</button>
        </div>
      `}).join('');
      
      // Update desktop basket
      if (basketDropdownContent) {
        basketDropdownContent.innerHTML = basketHTML;
      }
      
      // Update mobile basket
      if (basketDropdownContentMobile) {
        basketDropdownContentMobile.innerHTML = basketHTML;
      }

      // Show clear basket button when there are items
      const basketDropdownFooter = document.getElementById('basketDropdownFooter');
      const basketDropdownFooterMobile = document.getElementById('basketDropdownFooterMobile');
      if (basketDropdownFooter) {
        basketDropdownFooter.style.display = 'block';
      }
      if (basketDropdownFooterMobile) {
        basketDropdownFooterMobile.style.display = 'block';
      }

      
    }

    // Keep dropdown in sync with Firebase cart updates
    window.addEventListener('cartUpdated', updateBasketDropdown);

    // Minus button behavior (match belts.html): Firebase when logged in, localStorage otherwise
    document.addEventListener('click', async function(e) {
      const btn = e.target.closest('.basket-minus-btn');
      if (!btn) return;
      e.stopPropagation();
      e.preventDefault();

  const row = btn.closest('.basket-row');
      const itemId = btn.getAttribute('data-id');

      try {
        // If logged in, update Firebase cart
        if (window.FitRightFirebase && typeof window.FitRightFirebase.isLoggedIn === 'function' && window.FitRightFirebase.isLoggedIn()) {
          const items = window.FitRightFirebase.getCartItems();
          const item = items.find(it => (it.id || it.productId) == itemId);
          if (!item) {
            // Fallback: just refresh
            await window.FitRightFirebase.loadCart();
      return;
    }
          const currentQty = item.quantity || 1;
          if (currentQty > 1) {
            await window.FitRightFirebase.updateQuantity(item.id || item.productId, currentQty - 1);
          } else {
            // Fade out before removal for nicer UX
            if (row) row.classList.add('basket-fade-out');
            setTimeout(async () => {
              await window.FitRightFirebase.removeFromCart(item.id || item.productId);
            }, 300);
          }
          return;
        }

        // Guest mode: localStorage fallback
        const idx = parseInt(btn.getAttribute('data-index'));
      let currentBasket = JSON.parse(localStorage.getItem('basket')) || [];
      if (currentBasket[idx] && (currentBasket[idx].quantity || 1) > 1) {
        currentBasket[idx].quantity = (currentBasket[idx].quantity || 1) - 1;
        localStorage.setItem('basket', JSON.stringify(currentBasket));
        window.basket = currentBasket;
        updateBasketDropdown();
      } else if (currentBasket[idx]) {
        if (row) row.classList.add('basket-fade-out');
        setTimeout(() => {
          currentBasket.splice(idx, 1);
          localStorage.setItem('basket', JSON.stringify(currentBasket));
          window.basket = currentBasket;
          updateBasketDropdown();
        }, 300);
      }
      } catch (err) {
        console.error('Error updating cart item:', err);
      }
    });

    // Ensure Firebase cart is loaded on page load and render
    document.addEventListener('DOMContentLoaded', function() {
      if (window.FitRightFirebase && typeof window.FitRightFirebase.isLoggedIn === 'function' && window.FitRightFirebase.isLoggedIn()) {
        if (typeof window.FitRightFirebase.loadCart === 'function') {
          window.FitRightFirebase.loadCart().finally(() => updateBasketDropdown());
        } else {
          updateBasketDropdown();
        }
      } else {
        updateBasketDropdown();
      }
    });
    

    
    function removeFromBasket(index) {
      basket.splice(index, 1);
      localStorage.setItem("basket", JSON.stringify(basket));
      updateBasketDropdown();
    }
    
    function clearBasket() {
      window.basket = [];
      localStorage.setItem("basket", JSON.stringify(window.basket));
      updateBasketDropdown();
    }
    
    // Clear basket button functionality
    const clearBasketBtn = document.getElementById('clearBasketBtn');
    const clearBasketBtnMobile = document.getElementById('clearBasketBtnMobile');

    function clearBasket() {
      window.basket = [];
      localStorage.setItem("basket", JSON.stringify(window.basket));
      updateBasketDropdown();
      showToast("Basket cleared!");
    }

    if (clearBasketBtn) {
      clearBasketBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        if (confirm("Are you sure you want to clear your basket?")) {
          clearBasket();
        }
      });
    }
    
    if (clearBasketBtnMobile) {
      clearBasketBtnMobile.addEventListener('click', function(e) {
        e.stopPropagation();
        if (confirm("Are you sure you want to clear your basket?")) {
          clearBasket();
        }
      });
    }
    
    // Update basket count on page load
    updateBasketDropdown();
    // Update basket count when basket changes (listen to storage event for multi-tab)
    window.addEventListener('storage', function(e) {
      if (e.key === 'basket') updateBasketDropdown();
    });
  </script>
  <script>
    // Removed auto-open Try On behavior; Try On only starts on explicit user click
  </script>
  <script>
    // Close behavior: also close Try On UI when clicking outside its panel
    (function() {
      const modalEl = document.getElementById('productModal') || document.getElementById('modal');
      const uploadSection = document.getElementById('modelUploadSection');
      function hideTryOnCompletely() {
        // Persist loader if an AI job is in-flight; only hide overlay when idle
        try {
          const ov = document.getElementById('processingOverlayLocal');
          if (typeof isProcessing !== 'undefined' && isProcessing) {
            // Keep overlay visible and move it to <body> in full-screen mode
            if (ov) {
              try { if (ov.parentElement !== document.body) document.body.appendChild(ov); } catch(_) {}
              try { forceFullScreenOverlay = true; } catch(_) {}
              try { allowProcessingOverlay = true; } catch(_) {}
              ov.classList.add('show');
              ov.style.display = 'flex';
              ov.style.opacity = '1';
              ov.style.pointerEvents = 'auto';
              ov.style.zIndex = '4000';
              // Ensure it fills the viewport while the UI is hidden
              ov.style.position = 'fixed';
              ov.style.left = '0';
              ov.style.top = '0';
              ov.style.width = '100vw';
              ov.style.height = '100vh';
            }
          } else {
          if (ov) {
            ov.classList.remove('show');
            ov.style.opacity = '';
            ov.style.pointerEvents = '';
          }
          if (typeof allowProcessingOverlay !== 'undefined') allowProcessingOverlay = false;
          }
        } catch(_) {}
        window.tryOnActive = false;
        // Immediately fade out everything (arrows, floating image, upload section, modal)
        try { document.getElementById('tryOnArrows').classList.remove('show'); } catch(_) {}
        try {
          const floating = document.getElementById('floatingProductImage');
          if (floating) floating.remove();
        } catch(_) {}
        try {
          if (typeof resetTryOnStates === 'function') {
            resetTryOnStates();
          }
        } catch (_) {}
        if (uploadSection) {
          uploadSection.classList.remove('show');
          uploadSection.style.opacity = '0';
        }
        if (modalEl) {
          modalEl.classList.remove('show');
          modalEl.style.opacity = '0';
          setTimeout(() => { modalEl.style.display = 'none'; }, 180);
        }
      }
        // Close only when clicking on the dim overlay itself, not children/buttons
  if (uploadSection) {
    // Close when clicking anywhere outside the inner upload panel
    uploadSection.addEventListener('click', function(e) {
      const clickedInsidePanel = e.target.closest('.upload-container');
      if (!clickedInsidePanel) {
          hideTryOnCompletely();
        }
    });
  }
    })();
  </script>
  <script type="module" src="./firebase.js?v=2"></script>
  <script type="module" src="./fitright-cart-only.js?v=2"></script>
  <script src="./shared-basket-dropdown.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      if (window.FitRightFirebase && typeof window.FitRightFirebase.loadCart === 'function') {
        window.FitRightFirebase.loadCart().then(() => {
          try { window.dispatchEvent(new CustomEvent('cartUpdated')); } catch (_) {}
        }).catch(() => {});
      }
    });
  </script>
</body>
</html>

